<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DNS</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.tailwindcss.com"></script>
<style>
  :root {
    /* Base Colors */
    --clr-light: #f5f7fa;
    --clr-dark: #0d1117;

    /* Backgrounds */
    --bg-primary: #f8fbff; /* Lighter tint for subtle gradient effect */
    --bg-secondary: #ffffff;
    --bg-tertiary: #e8ecef; /* Accents, lighter alternate */
    --bg-gradient-light: radial-gradient(at 80% 0%, hsl(210, 100%, 98%), hsl(220, 14%, 96%) 80%);

    /* Text */
    --text-primary: #1a202c;
    --text-secondary: #4a5568;
    --text-muted: #718096;

    /* Borders & Dividers */
    --border-color: #d1d5db;
    --border-active: #a8b0bd; /* Slightly darker for active states */

    /* Interaction States */
    --hover-bg: #e0e9f6; /* Soft blue hover */
    --focus-ring: #a3c4f3; /* Gentle blue focus outline */

    /* Table Specifics */
    --table-header-bg: #eff3f7;
    --table-row-even: #f9fafb;
    --table-row-hover: #e0e9f6;

    /* Tooltips */
    --tooltip-bg: rgba(26, 32, 44, 0.85); /* Slightly transparent */
    --tooltip-text: #ffffff;

    /* Accents */
    --accent-blue: #3b82f6;
    --accent-blue-darker: #2563eb;
    --accent-blue-lighter: #60a5fa; /* For gradients */
    --accent-green: #10b981;
    --accent-red: #ef4444;

    /* Semantic Colors */
    --error-bg: #fef2f2;
    --error-text: #dc2626;
    --success-bg: #d1fae5;
    --success-text: #047857;
    --warning-bg: #fef3c7;
    --warning-text: #d97706;

    /* Shadows & Effects */
    --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.08);
    --shadow-md: 0 4px 10px rgba(0, 0, 0, 0.12);
    --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.15); /* For elevated elements */
    --btn-shadow: 0 4px 15px rgba(59, 130, 246, 0.25); /* Accent button shadow */
    --text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); /* Subtle text shadow */

    /* Typography */
    --font-size-base: clamp(14px, 2.5vw, 16px);
    --line-height-base: 1.6;

    /* Spacing & Radii */
    --spacing-xs: 0.25rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
    --radius-sm: 4px;
    --radius-md: 10px; /* Slightly larger radius for softer look */
    --radius-lg: 16px;
    --radius-full: 9999px;

    /* Transitions */
    --transition-fast: all 0.15s ease-out;
    --transition-base: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* ---------- Dark Mode ---------- */
  [data-theme="dark"] {
    /* Backgrounds */
    --bg-primary: #0a0e13; /* Darker base for subtle gradient */
    --bg-secondary: #161b22;
    --bg-tertiary: #1e2632; /* Accents, dark alternate */
    --bg-gradient-dark: radial-gradient(at 80% 0%, hsl(210, 10%, 15%), hsl(220, 14%, 10%) 80%);

    /* Text */
    --text-primary: #e6edf3;
    --text-secondary: #9ca3af;
    --text-muted: #6b7280;

    /* Borders & Dividers */
    --border-color: #30363d;
    --border-active: #48505e;

    /* Interaction States */
    --hover-bg: #21262d;
    --focus-ring: #4e7acb;

    /* Table Specifics */
    --table-header-bg: #1e2632;
    --table-row-even: #161b22;
    --table-row-hover: #2b3340;

    /* Tooltips */
    --tooltip-bg: rgba(230, 237, 243, 0.9); /* Inverted for dark mode, transparent */
    --tooltip-text: #0d1117;

    /* Accents */
    --accent-blue: #58a6ff;
    --accent-blue-darker: #1f6feb;
    --accent-blue-lighter: #82c4ff;
    --accent-green: #34d399;
    --accent-red: #f87171;

    /* Semantic Colors */
    --error-bg: #3b0000;
    --error-text: #ff8888;
    --success-bg: #004d3d;
    --success-text: #6ee7b7;
    --warning-bg: #5f4a00;
    --warning-text: #fcd34d;

    /* Shadows & Effects (more pronounced and diffused in dark mode) */
    --shadow-sm: 0 2px 6px rgba(0, 0, 0, 0.4);
    --shadow-md: 0 6px 16px rgba(0, 0, 0, 0.55);
    --shadow-lg: 0 12px 28px rgba(0, 0, 0, 0.65);
    --btn-shadow: 0 4px 18px rgba(88, 166, 255, 0.35);
    --text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
  }

  /* === BASE STYLES & RESETS === */
  *, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: 'Inter', sans-serif;
    background: var(--bg-primary);
    background-image: var(--bg-gradient-light);
    color: var(--text-primary);
    font-size: var(--font-size-base);
    line-height: var(--line-height-base);
    transition: background-color var(--transition-base), color var(--transition-base), background-image var(--transition-base);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  [data-theme="dark"] body {
    background-image: var(--bg-gradient-dark);
  }

  .container {
    max-width: 80rem;
    margin: 0 auto;
    padding: var(--spacing-lg);
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: var(--spacing-lg);
  }

  /* === Header === */
  .header {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg);
    padding: var(--spacing-lg);
    box-shadow: var(--shadow-md);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: var(--spacing-md);
    transition: var(--transition-base);
    backdrop-filter: blur(8px); /* Glassmorphism */
    -webkit-backdrop-filter: blur(8px);
  }
  .header h1 {
    font-weight: 700;
    color: var(--accent-blue);
    text-shadow: var(--text-shadow);
  }

  /* === Input Group === */
  .input-group {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    flex-grow: 1;
    flex-wrap: wrap;
  }

  /* Inputs, Selects */
  .input-focus {
    width: 100%;
    padding: var(--spacing-sm) var(--spacing-md);
    font-size: var(--font-size-base);
    color: var(--text-primary);
    background: var(--bg-tertiary); /* Slightly different background for inputs */
    border: 1px solid var(--border-color);
    border-radius: var(--radius-md);
    transition: var(--transition-fast);
  }
  .input-focus:hover {
    border-color: var(--border-active);
  }
  .input-focus:focus {
    outline: 2px solid var(--focus-ring);
    outline-offset: 2px;
    border-color: var(--accent-blue);
    box-shadow: 0 0 0 2px var(--focus-ring), 0 0 5px rgba(59, 130, 246, 0.3);
    background: var(--bg-secondary);
  }
  .input-focus::placeholder {
    color: var(--text-secondary);
    opacity: 0.7;
  }

  .filter-select {
    appearance: none;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-md);
    padding: var(--spacing-sm) 2rem var(--spacing-sm) var(--spacing-md);
    font-size: var(--font-size-base);
    color: var(--text-primary);
    cursor: pointer;
    transition: var(--transition-fast);
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234a5568' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 1rem;
    min-width: 120px;
  }
  [data-theme="dark"] .filter-select {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%239ca3af' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  }
  .filter-select:hover {
    border-color: var(--border-active);
  }
  .filter-select:focus {
    outline: 2px solid var(--focus-ring);
    outline-offset: 2px;
    border-color: var(--accent-blue);
    box-shadow: 0 0 0 2px var(--focus-ring), 0 0 5px rgba(59, 130, 246, 0.3);
  }

  /* Buttons */
  button:not(.btn-no-override) {
    --btn-bg-start: var(--accent-blue-lighter);
    --btn-bg-end: var(--accent-blue);
    --btn-text-color: var(--tooltip-text);
    --btn-shadow-color: rgba(59, 130, 246, 0.35);

    background: linear-gradient(135deg, var(--btn-bg-start) 0%, var(--btn-bg-end) 100%);
    color: var(--btn-text-color);
    border: none;
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--radius-md);
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-base);
    box-shadow: 0 4px 12px var(--btn-shadow-color);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-xs);
    position: relative;
    overflow: hidden;
  }
  button:not(.btn-no-override)::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, var(--btn-bg-end) 0%, var(--btn-bg-start) 100%);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 0;
  }
  button:not(.btn-no-override):hover::before {
    opacity: 1;
  }
  button:not(.btn-no-override) span, button:not(.btn-no-override) svg {
    position: relative;
    z-index: 1;
  }
  button:not(.btn-no-override):hover {
    box-shadow: 0 6px 20px var(--btn-shadow-color);
    transform: translateY(-2px);
  }
  button:not(.btn-no-override):active {
    transform: translateY(0);
    box-shadow: 0 2px 8px var(--btn-shadow-color);
  }
  button:not(.btn-no-override):disabled {
    opacity: 0.6;
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
  }
  button:not(.btn-no-override):disabled::before {
    opacity: 0;
  }

  /* Specific button overrides */
  #lookupBtn {
    --btn-bg-start: var(--accent-blue-lighter);
    --btn-bg-end: var(--accent-blue);
    --btn-shadow-color: rgba(59, 130, 246, 0.35);
    width: 48px; /* Fixed size for circular */
    height: 48px;
    border-radius: var(--radius-full);
    padding: 0; /* Override padding for circular */
    box-shadow: var(--btn-shadow);
  }
  [data-theme="dark"] #lookupBtn {
    --btn-bg-start: var(--accent-blue-lighter);
    --btn-bg-end: var(--accent-blue);
    --btn-shadow-color: rgba(88, 166, 255, 0.45);
  }
  #clearHistoryBtn {
    --btn-bg-start: #fca5a5; /* Red light */
    --btn-bg-end: #ef4444; /* Red base */
    --btn-text-color: white;
    --btn-shadow-color: rgba(239, 68, 68, 0.35);
    width: 48px;
    height: 48px;
    border-radius: var(--radius-full);
    padding: 0;
    box-shadow: 0 4px 12px var(--btn-shadow-color);
  }
  [data-theme="dark"] #clearHistoryBtn {
    --btn-bg-start: #ef4444;
    --btn-bg-end: #dc2626;
    --btn-shadow-color: rgba(239, 68, 68, 0.45);
  }

  #exportBtn {
    --btn-bg-start: #86efac; /* Green light */
    --btn-bg-end: #22c55e; /* Green base */
    --btn-text-color: white;
    --btn-shadow-color: rgba(34, 197, 94, 0.35);
    padding: var(--spacing-sm) var(--spacing-lg);
  }
  [data-theme="dark"] #exportBtn {
    --btn-bg-start: #4ade80;
    --btn-bg-end: #22c55e;
    --btn-shadow-color: rgba(34, 197, 94, 0.45);
  }

  .btn-no-override {
    background: none; /* remove gradient styling */
    color: inherit;
    box-shadow: none;
  }
  .btn-no-override:hover {
    background: none;
    box-shadow: none;
    transform: none;
  }
  .btn-no-override:active {
    transform: none;
    box-shadow: none;
  }
  .btn-no-override::before { /* remove glow on hover */
    display: none;
  }

  /* Icons */
  .search-icon, .clear-icon, .export-icon {
    width: 1.25rem;
    height: 1.25rem;
    fill: var(--btn-text-color);
    transition: fill var(--transition-fast);
  }
  .loading-spinner {
    width: 1.5rem;
    height: 1.5rem;
    border: 3px solid var(--btn-text-color);
    border-top-color: transparent;
  }


  /* === Record Section === */
  .record-section {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg);
    margin-bottom: var(--spacing-md);
    overflow: hidden;
    transition: var(--transition-base);
    box-shadow: var(--shadow-md);
    backdrop-filter: blur(5px); /* Glassmorphism */
    -webkit-backdrop-filter: blur(5px);
  }
  .record-section summary {
    padding: var(--spacing-md) var(--spacing-lg);
    background: var(--table-header-bg);
    font-weight: 600;
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    transition: var(--transition-fast);
    border-bottom: 1px solid var(--border-color);
  }
  .record-section summary:hover {
    background: var(--hover-bg);
  }
  .record-section summary:focus {
    outline: 2px solid var(--focus-ring);
    outline-offset: -2px; /* Inset focus for summary */
    border-radius: var(--radius-md); /* Match summary radius */
  }
  .record-section summary::-webkit-details-marker { display: none; }
  .record-section summary::after {
    content: 'â–¼';
    font-size: 0.75rem;
    margin-left: auto;
    transition: transform 0.2s ease;
    color: var(--text-secondary);
  }
  .record-section[open] summary::after { transform: rotate(180deg); }

  /* === Table === */
  .table-container {
    overflow-x: auto;
    padding: var(--spacing-lg);
  }
  .dns-table { width: 100%; border-collapse: collapse; }
  .dns-table th, .dns-table td {
    padding: var(--spacing-md);
    text-align: left;
    border-bottom: 1px solid var(--border-color);
    color: var(--text-primary);
    font-size: var(--font-size-base);
  }
  .dns-table th {
    font-weight: 600;
    background: var(--table-header-bg);
    cursor: pointer;
    user-select: none;
    transition: var(--transition-fast);
  }
  .dns-table th:hover { background: var(--hover-bg); }
  .dns-table th:focus {
    outline: 2px solid var(--focus-ring);
    outline-offset: -2px;
  }
  .dns-table tr:nth-child(even) { background: var(--table-row-even); }
  .dns-table tr:hover { background: var(--table-row-hover); }

  /* Sort Icon */
  .sort-icon {
    display: inline-block;
    width: 0.85rem;
    height: 0.85rem;
    margin-left: var(--spacing-xs);
    vertical-align: middle;
    fill: var(--text-secondary);
    transition: var(--transition-fast);
  }
  .sort-icon.asc { transform: rotate(180deg); }

  /* === Copyable Elements === */
  .copyable {
    cursor: pointer;
    position: relative;
    display: inline-flex;
    align-items: center;
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--radius-sm);
    transition: var(--transition-fast);
  }
  .copyable:hover {
    background: var(--hover-bg);
    text-decoration: underline;
    text-decoration-color: var(--accent-blue-lighter);
  }
  .copyable:focus {
    outline: 2px solid var(--focus-ring);
    outline-offset: 2px;
  }
  .copy-icon {
    opacity: 0;
    margin-left: var(--spacing-xs);
    width: 0.85rem;
    height: 0.85rem;
    fill: var(--accent-blue);
    transition: var(--transition-fast);
  }
  .copyable:hover .copy-icon, .copyable:focus .copy-icon { opacity: 1; }
  .copyable.copied .copy-icon { opacity: 1; fill: var(--accent-green); transform: scale(1.1); }
  .copy-tooltip {
    background: var(--tooltip-bg);
    color: var(--tooltip-text);
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--radius-sm);
    font-size: 0.75rem;
    white-space: nowrap;
    pointer-events: none;
    z-index: 20;
    opacity: 0;
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    backdrop-filter: blur(4px); /* Glassmorphism */
    -webkit-backdrop-filter: blur(4px);
    position: absolute;
    top: -2rem; /* Initial position */
    left: 50%;
    transform: translateX(-50%) translateY(5px); /* Start slightly offset */
  }
  .copyable:hover .copy-tooltip--hover, .copyable:focus .copy-tooltip--hover {
    opacity: 1;
    transform: translateX(-50%) translateY(0); /* Move to final position */
  }
  .copyable.copied .copy-tooltip--copied {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
    top: -2rem;
  }

  /* === Info Icon === */
  .info-icon {
    position: relative;
    display: inline-block;
    width: 0.95rem;
    height: 0.95rem;
    margin-left: var(--spacing-xs);
    fill: var(--text-muted);
    cursor: pointer;
    vertical-align: middle;
    transition: var(--transition-fast);
  }
  .info-icon:hover, .info-icon:focus { transform: scale(1.15); fill: var(--accent-blue); }
  .info-icon:focus { outline: none; } /* Handled by pseudo element on parent */
  .info-tooltip {
    background: var(--tooltip-bg);
    color: var(--tooltip-text);
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--radius-sm);
    font-size: 0.75rem;
    white-space: nowrap;
    pointer-events: none;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    backdrop-filter: blur(4px); /* Glassmorphism */
    -webkit-backdrop-filter: blur(4px);
    position: absolute;
    top: -2.5rem; /* Initial position */
    left: 50%;
    transform: translateX(-50%) translateY(5px);
  }
  .info-icon:hover .info-tooltip, .info-icon:focus .info-tooltip {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  /* === Autocomplete === */
  #domainInputContainer { position: relative; flex-grow: 1; }
  #domainAutocompleteList {
    border: 1px solid var(--border-active);
    border-top: none;
    z-index: 10;
    background: var(--bg-secondary);
    max-height: 12.5rem;
    overflow-y: auto;
    box-shadow: var(--shadow-md);
    border-radius: 0 0 var(--radius-md) var(--radius-md);
    transition: var(--transition-fast);
    width: 100%;
    position: absolute;
    top: 100%; /* Position right below the input */
    left: 0;
  }
  #domainAutocompleteList div {
    padding: var(--spacing-sm) var(--spacing-md);
    cursor: pointer;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    color: var(--text-primary);
    transition: var(--transition-fast);
  }
  #domainAutocompleteList div:last-child { border-bottom: none; }
  #domainAutocompleteList div:hover,
  #domainAutocompleteList div.autocomplete-active {
    background: var(--hover-bg);
    color: var(--accent-blue-darker);
  }

  /* === Record States === */
  .record-row-added { background: var(--success-bg); color: var(--success-text); }
  .record-row-deleted { background: var(--error-bg); color: var(--error-text); text-decoration: line-through; opacity: 0.7; }
  .record-row-modified { background: var(--warning-bg); color: var(--warning-text); }
  .record-row-added:hover, .record-row-deleted:hover, .record-row-modified:hover { filter: brightness(98%); } /* Subtle hover */

  /* === Initial Message === */
  .initial-message {
    text-align: center;
    padding: var(--spacing-lg) var(--spacing-xl);
    color: var(--text-secondary);
    font-size: var(--font-size-base);
    line-height: var(--line-height-base);
    background: var(--bg-secondary);
    border-radius: var(--radius-lg);
    border: 2px dashed var(--border-color); /* More prominent dashed border */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: var(--transition-base);
    box-shadow: var(--shadow-sm);
  }
  .initial-message svg {
    width: 3.5rem; /* Larger icon */
    height: 3.5rem;
    fill: var(--text-muted);
    margin-bottom: var(--spacing-md);
    filter: drop-shadow(var(--text-shadow)); /* Drop shadow for icon */
  }
  .initial-message p:first-child { font-weight: 600; margin-bottom: var(--spacing-sm); color: var(--text-primary);}
  .initial-message p:last-child { font-size: 0.9rem; }


  /* === User Feedback Container (Toast Notifications) === */
  #userFeedbackContainer {
    position: fixed;
    top: var(--spacing-lg);
    left: 50%;
    transform: translateX(-50%);
    z-index: 10000;
    min-width: 20rem;
    max-width: clamp(20rem, 90%, 30rem); /* Max width adjusted */
    padding: var(--spacing-md) var(--spacing-lg);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-lg); /* More prominent shadow */
    text-align: center;
    font-size: 0.95rem;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out, transform 0.3s ease-in-out;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-sm);
    backdrop-filter: blur(10px); /* Frosted */
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle white border for glass effect */
  }
  [data-theme="dark"] #userFeedbackContainer {
     border: 1px solid rgba(0, 0, 0, 0.2);
  }

  #userFeedbackContainer.show {
    opacity: 1;
    visibility: visible;
    transform: translateX(-50%) translateY(0);
  }
  #userFeedbackContainer svg {
    width: 1.25rem;
    height: 1.25rem;
    flex-shrink: 0;
  }

  #userFeedbackContainer.error { background: var(--error-bg); color: var(--error-text); }
  #userFeedbackContainer.error svg { fill: var(--error-text); }
  #userFeedbackContainer.warning { background: var(--warning-bg); color: var(--warning-text); }
  #userFeedbackContainer.warning svg { fill: var(--warning-text); }
  #userFeedbackContainer.success { background: var(--success-bg); color: var(--success-text); }
  #userFeedbackContainer.success svg { fill: var(--success-text); }
  #userFeedbackContainer.info { background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-active);}
  #userFeedbackContainer.info svg { fill: var(--text-secondary); }


  /* === Toggle Switch === */
  .theme-toggle {
    position: relative;
    display: inline-block;
    width: 3.2rem; /* Slightly wider */
    height: 1.7rem; /* Slightly taller */
  }
  .theme-toggle input { opacity: 0; width: 0; height: 0; }
  .theme-toggle-slider {
    position: absolute;
    cursor: pointer;
    inset: 0;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-full);
    transition: var(--transition-fast);
  }
  .theme-toggle-slider:before {
    position: absolute;
    content: "";
    height: 1.25rem; /* Larger circle */
    width: 1.25rem;
    left: 0.2rem; /* Adjusted position */
    bottom: 0.16rem;
    background: var(--text-primary);
    border-radius: var(--radius-full);
    transition: var(--transition-fast);
    box-shadow: var(--shadow-sm);
  }
  /* Dark mode visual indicator */
  [data-theme="dark"] .theme-toggle-slider:before {
    background: var(--text-primary);
    transform: translateX(1.5rem);
  }
  /* Light mode visual indicator */
  .theme-toggle input:not(:checked) + .theme-toggle-slider:before {
    background: var(--accent-blue-lighter);
  }

  .theme-toggle input:checked + .theme-toggle-slider {
    background: var(--accent-blue);
    border-color: var(--accent-blue);
  }
  .theme-toggle input:checked + .theme-toggle-slider:before {
    transform: translateX(1.5rem);
  }
  .theme-toggle input:focus + .theme-toggle-slider {
    box-shadow: 0 0 0 2px var(--focus-ring);
    outline: 2px solid transparent; /* Hide browser default outline */
  }

  /* === Footer === */
  .footer {
    text-align: center;
    padding: var(--spacing-md) 0;
    color: var(--text-muted);
    font-size: 0.8rem;
  }

  /* === RESPONSIVE ENHANCEMENTS === */
  @media (max-width: 900px) {
    .container {
      padding: var(--spacing-md);
      gap: var(--spacing-md);
    }
    .header {
      flex-direction: column;
      align-items: stretch;
      padding: var(--spacing-md);
      border-radius: var(--radius-md);
    }
    .input-group {
      flex-direction: column;
      width: 100%;
      gap: var(--spacing-sm);
    }
    input[type="text"], .filter-select, .input-focus,
    button:not(.btn-no-override), .btn:not(.btn-no-override) {
      width: 100%; max-width: 100%; font-size: 1rem; box-sizing: border-box;
      min-height: 48px; /* Bigger tap targets */
    }
    #lookupBtn, #clearHistoryBtn {
      width: 48px; height: 48px; /* Keep circular buttons fixed size */
      align-self: flex-end; /* Align right */
      margin-left: auto; /* Push to right if group is row, otherwise no effect */
    }
    .table-container { padding: var(--spacing-sm); }
    .dns-table th, .dns-table td {
      font-size: 0.95rem; padding: 0.6rem 0.75rem; white-space: nowrap;
    }
    .record-section summary { font-size: 1rem; padding: 0.75rem; border-radius: var(--radius-md);}
    .copy-tooltip, .info-tooltip { top: auto; bottom: -2rem; font-size: 0.7rem; }
    .initial-message { padding: var(--spacing-md) var(--spacing-sm); font-size: 0.95rem; border-radius: var(--radius-md); }
    .footer { font-size: 0.75rem; padding: var(--spacing-sm); }

    #userFeedbackContainer {
      top: var(--spacing-sm);
      max-width: 95%;
      padding: var(--spacing-sm) var(--spacing-md);
    }
  }

  @media (max-width: 480px) {
    body { font-size: 0.9rem; }
    .header { padding: var(--spacing-sm); }
    .dns-table th, .dns-table td { padding: 0.4rem 0.5rem; }
    .record-section summary { font-size: 0.95rem; }
    button:not(.btn-no-override), .btn:not(.btn-no-override) {
      padding: 0.6rem 0.75rem; font-size: 0.95rem; min-height: 44px;
    }
  }

  @media (hover: none) {
    .copyable:hover, .info-icon:hover, .dns-table th:hover, .record-section summary:hover {
      background: none; transform: none;
    }
    .copyable:hover .copy-icon, .copyable:focus .copy-icon { opacity: 1; }
    button:not(.btn-no-override):hover::before { opacity: 0; }
  }
</style>
</head>
<body>
  <div id="userFeedbackContainer" aria-live="polite" role="status">
    <!-- Feedback message and icon will be inserted here by JS -->
  </div>
  <div class="container">
    <div class="header">
      <h1 class="text-2xl">
        DNS Lookup
      </h1>
      <div class="input-group">
        <div id="domainInputContainer">
          <input
            id="domainInput"
            type="text"
            placeholder="Enter domain (e.g., example.com)"
            class="input-focus"
            aria-label="Domain name for DNS lookup"
            aria-autocomplete="list"
            aria-controls="domainAutocompleteList"
            autocomplete="off"
            value=""
          />
          <div id="domainAutocompleteList" class="hidden" role="listbox"></div>
        </div>
      <button
          id="lookupBtn"
          aria-label="Search DNS records"
        >
          <span id="currentSearchIcon">
            <svg id="searchIcon" class="search-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 1 0-.7.7l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9z"/></svg>
          </span>
        </button>
        <button
          id="clearHistoryBtn"
          aria-label="Clear all stored history and records"
          class="btn-no-override"
          title="Clear all stored history and records"
        >
          <svg class="clear-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41z"/>
          </svg>
        </button>
        <label class="theme-toggle" aria-label="Toggle dark/light mode">
          <input
            type="checkbox"
            id="themeToggle"
            role="switch"
            aria-checked="false"
          />
          <span class="theme-toggle-slider"></span>
        </label>
      </div>
    </div>
    <div id="result">
      <div id="initialMessage" class="initial-message">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"></path>
        </svg>
        <p>Start your DNS lookup</p>
        <p class="text-sm text-[var(--text-secondary)]">
          Enter a domain name above to retrieve its DNS records.
        </p>
      </div>
      <div
        id="resultsHeader"
        class="flex flex-col sm:flex-row justify-between items-center mb-4 hidden"
      >
        <h2 class="text-lg font-semibold text-[var(--text-primary)] mb-2 sm:mb-0">
          DNS Records for <span id="currentDomainDisplay" class="font-bold text-[var(--accent-blue)]"></span>
        </h2>
        <div class="flex flex-wrap gap-2 items-center">
          <select
            id="filterType"
            class="filter-select"
            aria-label="Filter by record type"
          >
            <option value="">All Types</option>
            <option value="A">A</option>
            <option value="AAAA">AAAA</option>
            <option value="CNAME">CNAME</option>
            <option value="MX">MX</option>
            <option value="NS">NS</option>
            <option value="TXT">TXT</option>
          </select>
          <button
            id="exportBtn"
            aria-label="Export DNS records to a text file"
            class="hidden"
            title="Export Records"
          >
            Export .TXT
            <svg class="export-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
          </button>
        </div>
      </div>
      <div id="historySelectContainer" class="flex items-center gap-2 mb-4 hidden"></div>
      <div id="resultSections"></div>
    </div>
    <div
      id="error"
      class="mt-4 hidden"
    ></div>
    <div class="footer">
      <small>
        <b>DNS</b> Version: <b>1.5</b>
      </small>
    </div>
    <div aria-live="polite" class="sr-only" id="copy-status"></div>
  </div>
  <script>
    // DOM elements
    const DOMElements = {
      lookupBtn: document.getElementById('lookupBtn'),
      currentSearchIcon: document.getElementById('currentSearchIcon'),
      domainInput: document.getElementById('domainInput'),
      domainInputContainer: document.getElementById('domainInputContainer'),
      domainAutocompleteList: document.getElementById('domainAutocompleteList'),
      resultDiv: document.getElementById('result'),
      resultSections: document.getElementById('resultSections'),
      errorDiv: document.getElementById('error'), // Deprecated, but kept for removal clarity
      filterType: document.getElementById('filterType'),
      copyStatus: document.getElementById('copy-status'),
      initialMessage: document.getElementById('initialMessage'),
      resultsHeader: document.getElementById('resultsHeader'),
      clearHistoryBtn: document.getElementById('clearHistoryBtn'),
      exportBtn: document.getElementById('exportBtn'),
      themeToggle: document.getElementById('themeToggle'),
      userFeedbackContainer: document.getElementById('userFeedbackContainer'),
      currentDomainDisplay: document.getElementById('currentDomainDisplay'),
      historySelectContainer: document.getElementById('historySelectContainer'), // Initialized later
    };

    // Constants
    const RECORD_TYPES = ['A', 'AAAA', 'CNAME', 'MX', 'NS', 'TXT'];
    const API_URL = 'https://1.1.1.1/dns-query';
    const LOCAL_STORAGE_HISTORY_KEY = 'dnsLookupHistory';
    const LOCAL_STORAGE_RECORDS_KEY = 'dnsStoredRecords';
    const LOCAL_STORAGE_THEME_KEY = 'dnsTheme';
    const MAX_HISTORY_ITEMS = 10;
    const MAX_SNAPSHOTS_PER_DOMAIN = 5;
    const DEBOUNCE_DELAY = 300;
    const FEEDBACK_DISPLAY_TIME = 4000; // Time in ms to show user feedback

    // State (centralized)
    const appState = {
      dnsRecords: [],
      currentSort: {}, // { 'A': {column: 'name', direction: 'asc'}, ... }
      currentAutocompleteFocus: -1,
      currentDomain: '',
      currentSnapshotIndex: -1,
      debounceTimeout: null,
      theme: 'light',
      isLoading: false,
    };

    // SVG icons (Using a consistent source for a modern feel)
    const SVGS = {
      copy: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16 4.01C16 3.45 15.55 3 15 3H7C6.45 3 6 3.45 6 4.01V18.99C6 19.55 6.45 20 7 20H15C15.55 20 16 19.55 16 18.99V4.01ZM18 6V21.01C18 21.55 17.55 22 17 22H9C8.45 22 8 21.55 8 21.01V19H17C17.55 19 18 18.55 18 18V6ZM14 17H8V5H14V17Z"/></svg>`,
      checkmark: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M9 20.4L3.6 15L5 13.6L9 17.6L19.4 7.2L20.8 8.6L9 20.4Z"/></svg>`,
      info: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 15a1 1 0 1 1 0-2 1 1 1 1 0 2zm0-4a1 1 0 0 1-1-1V7a1 1 0 0 1 2 0v5a1 1 0 0 1-1 1z"/></svg>`,
      sort: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2.5a.5.5 0 0 1 .5.5v16.79l2.4-2.4a.5.5 0 0 1 .71.71l-3.2 3.2a.5.5 0 0 1-.7 0l-3.2-3.2a.5.5 0 1 1 .7-.71l2.4 2.4V3a.5.5 0 0 1 .5-.5z"/></svg>`,
      search: `<svg class="search-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 1 0-.7.7l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9z"/></svg>`,
      warning: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 15v-2h2v2h-2zm0-4V7h2v6h-2z"/></svg>`,
      error: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"/></svg>`,
      success: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8.59 10 17z"/></svg>`,
    };

    let userFeedbackTimeout;
    function showUserFeedback(message, type = 'info', duration = FEEDBACK_DISPLAY_TIME) {
      clearTimeout(userFeedbackTimeout);
      const feedbackDiv = DOMElements.userFeedbackContainer;
      
      // Determine icon based on type
      let iconSvg = '';
      if (type === 'error') iconSvg = SVGS.error;
      else if (type === 'warning') iconSvg = SVGS.warning;
      else if (type === 'success') iconSvg = SVGS.success;
      // For 'info', you might use a general info icon or leave it empty

      feedbackDiv.innerHTML = `${iconSvg ? `<span class="feedback-icon">${iconSvg}</span>` : ''} <span>${message}</span>`;
      feedbackDiv.className = ''; // Reset classes
      feedbackDiv.classList.add('show', type);
      userFeedbackTimeout = setTimeout(() => {
        feedbackDiv.classList.remove('show');
      }, duration);
    }


    // --- State Management and UI Update ---
    function updateState(newState, reRender = true) {
      Object.assign(appState, newState);
      if (!reRender) return;

      if (newState.currentDomain !== undefined) {
        DOMElements.currentDomainDisplay.textContent = appState.currentDomain;
        populateHistoryDropdown(appState.currentDomain);
      }
      if (newState.dnsRecords !== undefined || newState.filterType !== undefined || newState.currentSort !== undefined) {
        renderSections(appState.dnsRecords);
      }
      if (newState.isLoading !== undefined) {
        DOMElements.lookupBtn.disabled = appState.isLoading;
        DOMElements.domainInput.disabled = appState.isLoading;
        DOMElements.filterType.disabled = appState.isLoading;
        DOMElements.exportBtn.disabled = appState.isLoading;
        DOMElements.currentSearchIcon.innerHTML = appState.isLoading ? `<span class="loading-spinner"></span>` : SVGS.search;
      }
      if (newState.theme !== undefined) {
          document.documentElement.setAttribute('data-theme', appState.theme);
          DOMElements.themeToggle.checked = appState.theme === 'dark';
          DOMElements.themeToggle.setAttribute('aria-checked', appState.theme === 'dark');
      }
    }

    // Utility functions
    function escapeHtmlAttribute(value) {
      if (value === null || value === undefined) return '';
      return String(value)
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function normalizeTxtData(data) {
      if (Array.isArray(data)) {
        return data.join(' ').replace(/^"(.*)"$/, '$1').replace(/\s+/g, ' ').trim();
      }
      if (typeof data === 'string') {
        return data.replace(/^"(.*)"$/, '$1').replace(/\s+/g, ' ').trim();
      }
      return String(data).replace(/^"(.*)"$/, '$1').replace(/\s+/g, '$1').trim();
    }

    function isValidDomain(domain) {
      const domainRegex =
        /^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
      return (
        domainRegex.test(domain) &&
        domain.length <= 253 &&
        !domain.includes('..') &&
        !domain.startsWith('-') &&
        !domain.endsWith('-')
      );
    }

    function showError(message) {
      console.error('Error:', message);
      showUserFeedback(message, 'error');
      DOMElements.initialMessage.classList.add('hidden');
      DOMElements.resultsHeader.classList.add('hidden');
      DOMElements.historySelectContainer.classList.add('hidden');
      DOMElements.exportBtn.classList.add('hidden');
      DOMElements.resultSections.innerHTML = '';
    }

    function resetUI() {
      showUserFeedback('', 'info', 0); // Clear any existing feedback
      DOMElements.resultSections.innerHTML = '';
      updateState({
        dnsRecords: [],
        currentAutocompleteFocus: -1,
        currentDomain: '',
        currentSnapshotIndex: -1,
        isLoading: false,
      }, false); // Don't re-render everything on reset, will be done selectively
      DOMElements.filterType.value = '';
      DOMElements.initialMessage.classList.remove('hidden');
      DOMElements.resultsHeader.classList.add('hidden');
      DOMElements.historySelectContainer.classList.add('hidden');
      DOMElements.exportBtn.classList.add('hidden');
      RECORD_TYPES.forEach((type) => {
        appState.currentSort[type] = { column: 'name', direction: 'asc' };
      });
      hideAutocompleteList();
      DOMElements.domainInput.value = '';
      DOMElements.currentDomainDisplay.textContent = '';
    }

    async function copyToClipboard(text, element, field) {
      const announceStatus = (message) => {
        DOMElements.copyStatus.textContent = message;
        setTimeout(() => {
          DOMElements.copyStatus.textContent = '';
        }, 3000);
      };
      try {
        await navigator.clipboard.writeText(text);
        element.classList.add('copied');
        element.querySelector('.copy-icon').innerHTML = SVGS.checkmark;
        announceStatus(`Copied ${field} to clipboard.`);
        setTimeout(() => {
          element.classList.remove('copied');
          element.querySelector('.copy-icon').innerHTML = SVGS.copy;
        }, 2000);
      } catch (err) {
        console.error(`Clipboard API failed for ${field}:`, err);
        announceStatus('Failed to copy: Please grant clipboard access or try again.');
        try {
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand('copy');
          document.body.removeChild(textarea);
          element.classList.add('copied');
          element.querySelector('.copy-icon').innerHTML = SVGS.checkmark;
          announceStatus(`Copied ${field} to clipboard (fallback).`);
          setTimeout(() => {
            element.classList.remove('copied');
            element.querySelector('.copy-icon').innerHTML = SVGS.copy;
          }, 2000);
        } catch (fallbackErr) {
          console.error(`Fallback copy failed for ${field}:`, fallbackErr);
          announceStatus('Failed to copy: Your browser does not support clipboard operations.');
        }
      }
    }

    function sortRecords(records, column, direction) {
      const statusOrder = {
        added: 1,
        modified: 2,
        deleted: 3,
        unchanged: 4,
        undefined: 5
      };

      return [...records].sort((a, b) => {
        const statusCompare = statusOrder[a.status] - statusOrder[b.status];
        if (statusCompare !== 0) return statusCompare;

        let valueA = a[column];
        let valueB = b[column];

        if (column === 'data') {
          valueA = a.type === 'TXT' ? normalizeTxtData(valueA) : String(valueA);
          valueB = b.type === 'TXT' ? normalizeTxtData(valueB) : String(valueB);
        } else if (column === 'ttl') {
          valueA = parseInt(a.ttl, 10) || 0;
          valueB = parseInt(b.ttl, 10) || 0;
        } else {
          valueA = String(valueA).toLowerCase();
          valueB = String(valueB).toLowerCase();
        }

        if (valueA < valueB) return direction === 'asc' ? -1 : 1;
        if (valueA > valueB) return direction === 'asc' ? 1 : -1;
        return 0;
      });
    }

    function renderTable(records, type) {
      if (!records || records.length === 0) {
        return `<p class="text-center text-[var(--text-secondary)] py-4">No ${type} records found.</p>`;
      }
      const sortCol = appState.currentSort[type].column;
      const sortDir = appState.currentSort[type].direction;
      const sortedRecords = sortRecords(records, sortCol, sortDir);
      let html = `
        <div class="table-container">
          <table class="dns-table" role="table" aria-label="${type} DNS Records">
            <thead>
              <tr>
                <th scope="col" data-sort="name" data-type="${type}" tabindex="0" aria-sort="${
                  sortCol === 'name' ? (sortDir === 'asc' ? 'ascending' : 'descending') : 'none'
                }">Name <span class="sort-icon ${sortCol === 'name' && sortDir === 'asc' ? 'asc' : ''}">${
                  sortCol === 'name' ? SVGS.sort : ''
                }</span></th>
                <th scope="col" data-sort="data" data-type="${type}" tabindex="0" aria-sort="${
                  sortCol === 'data' ? (sortDir === 'asc' ? 'ascending' : 'descending') : 'none'
                }">Data <span class="sort-icon ${sortCol === 'data' && sortDir === 'asc' ? 'asc' : ''}">${
                  sortCol === 'data' ? SVGS.sort : ''
                }</span></th>
                <th scope="col" data-sort="ttl" data-type="${type}" tabindex="0" aria-sort="${
                  sortCol === 'ttl' ? (sortDir === 'asc' ? 'ascending' : 'descending') : 'none'
                }">TTL <span class="sort-icon ${sortCol === 'ttl' && sortDir === 'asc' ? 'asc' : ''}">${
                  sortCol === 'ttl' ? SVGS.sort : ''
                }</span></th>
              </tr>
            </thead>
            <tbody>
      `;
      sortedRecords.forEach((record) => {
        const normalizedData = record.type === 'TXT' ? normalizeTxtData(record.data) : record.data;
        const normalizedTTL = record.ttl !== 'N/A' ? String(record.ttl) : 'N/A';
        const rowClass = record.status && ['added', 'modified', 'deleted'].includes(record.status)
          ? `record-row-${record.status}`
          : '';

        let oldDataDisplay = '';
        if (record.status === 'modified' && record.oldData !== undefined) {
          const oldNormalizedData = record.type === 'TXT' ? normalizeTxtData(record.oldData) : record.oldData;
          oldDataDisplay = `<span class="text-[var(--text-secondary)] text-xs ml-1">(was: ${escapeHtmlAttribute(oldNormalizedData)})</span>`;
        }

        let statusIndicator = '';
        if (record.status === 'added') {
          statusIndicator = '<span class="text-green-600 text-xs font-semibold ml-1">(New)</span>';
        } else if (record.status === 'modified') {
          statusIndicator = '<span class="text-yellow-600 text-xs font-semibold ml-1">(Changed)</span>';
        } else if (record.status === 'deleted') {
          statusIndicator = '<span class="text-red-600 text-xs font-semibold ml-1">(Deleted)</span>';
        } else if (record.status === 'unchanged' && appState.currentSnapshotIndex > -1) {
          statusIndicator = '<span class="text-[var(--text-secondary)] text-xs font-semibold ml-1">(Unchanged)</span>';
        }

        html += `
          <tr class="${rowClass}">
            <td role="cell">
              <span class="copyable" role="button" tabindex="0" data-copy="${escapeHtmlAttribute(record.name)}" aria-label="Copy DNS name: ${escapeHtmlAttribute(record.name)}">
                ${escapeHtmlAttribute(record.name)}
                ${statusIndicator}
                <span class="copy-icon">${SVGS.copy}</span>
                <span class="copy-tooltip copy-tooltip--hover">Copy</span>
                <span class="copy-tooltip copy-tooltip--copied">Copied!</span>
              </span>
            </td>
            <td role="cell">
              <span class="copyable" role="button" tabindex="0" data-copy="${escapeHtmlAttribute(normalizedData)}" aria-label="Copy DNS data: ${escapeHtmlAttribute(normalizedData)}">
                ${escapeHtmlAttribute(normalizedData)}
                ${oldDataDisplay}
                <span class="copy-icon">${SVGS.copy}</span>
                <span class="copy-tooltip copy-tooltip--hover">Copy</span>
                <span class="copy-tooltip copy-tooltip--copied">Copied!</span>
              </span>
            </td>
            <td role="cell">
              <span class="copyable" role="button" tabindex="0" data-copy="${escapeHtmlAttribute(normalizedTTL)}" aria-label="Copy DNS TTL: ${escapeHtmlAttribute(normalizedTTL)}">
                ${normalizedTTL}
                <span class="copy-icon">${SVGS.copy}</span>
                <span class="copy-tooltip copy-tooltip--hover">Copy</span>
                <span class="copy-tooltip copy-tooltip--copied">Copied!</span>
              </span>
            </td>
          </tr>
        `;
      });
      html += `
            </tbody>
          </table>
        </div>
      `;
      return html;
    }

    function renderSections(records) {
      DOMElements.resultSections.innerHTML = '';
      const filterValue = DOMElements.filterType.value;
      let anySectionsRendered = false;

      RECORD_TYPES.forEach((type) => {
        const typeRecords = records.filter((record) => record.type === type);
        if (filterValue && filterValue !== type) return;

        if (!appState.currentSort[type]) {
          appState.currentSort[type] = { column: 'name', direction: 'asc' };
        }

        if (typeRecords.length === 0) return;

        anySectionsRendered = true;
        const sectionId = `section-${type}`;
        const section = document.createElement('details');
        section.className = 'record-section';
        section.id = sectionId;
        section.open = true;
        section.setAttribute('role', 'group');
        section.setAttribute('aria-labelledby', `${sectionId}-summary`);
        section.setAttribute('aria-expanded', 'true'); // Details are open by default

        // Dynamically create summary element for ARIA
        const summary = document.createElement('summary');
        summary.id = `${sectionId}-summary`;
        summary.setAttribute('aria-expanded', 'true');
        summary.setAttribute('aria-controls', `${sectionId}-content`);
        summary.innerHTML = `
            ${type} Records
            <span class="info-icon" tabindex="0" role="button" aria-label="Learn about ${type} records">
              ${SVGS.info}
              <span class="info-tooltip">${RECORD_DESCRIPTIONS[type] || 'No description available.'}</span>
            </span>
            <span class="record-count">(${typeRecords.length})</span>
        `;
        section.appendChild(summary);

        const contentDiv = document.createElement('div');
        contentDiv.id = `${sectionId}-content`;
        contentDiv.innerHTML = renderTable(typeRecords, type);
        section.appendChild(contentDiv);
        
        DOMElements.resultSections.appendChild(section);

        // Add event listener to toggle aria-expanded when details element is opened/closed
        section.addEventListener('toggle', () => {
          summary.setAttribute('aria-expanded', section.open ? 'true' : 'false');
        });
      });

      if (!anySectionsRendered) {
        DOMElements.resultSections.innerHTML = `
          <div class="initial-message">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/>
            </svg>
            <p>No DNS records found for the applied filter.</p>
            <p class="text-sm text-[var(--text-secondary)]">Try adjusting your filter or searching for a different domain.</p>
          </div>
        `;
        DOMElements.initialMessage.classList.add('hidden');
        DOMElements.exportBtn.classList.add('hidden');
      } else {
        DOMElements.exportBtn.classList.remove('hidden');
      }
    }


    async function fetchDNSRecord(domain, type) {
      try {
        const response = await fetch(
          `${API_URL}?name=${encodeURIComponent(domain)}&type=${type}`,
          { headers: { Accept: 'application/dns-json' } }
        );
        if (!response.ok) {
          throw new Error(`DNS query failed for ${type} records: HTTP ${response.status} - ${response.statusText}`);
        }
        const data = await response.json();
        return { type, data };
      } catch (error) {
        console.error(`Fetch error for ${type} record type:`, error);
        return { type, data: { Status: -1, Comment: error.message, Answer: [] } };
      }
    }

    async function performDNSLookup(domain) {
      if (appState.isLoading) return; // Prevent multiple lookups
      if (!domain) {
        showError('Please enter a domain name.');
        return;
      }
      resetUI();
      updateState({ isLoading: true, currentDomain: domain.toLowerCase() });

      try {
        if (!isValidDomain(domain)) {
          showError('Please enter a valid domain name (e.g., example.com).');
          return;
        }

        const promises = RECORD_TYPES.map((type) => fetchDNSRecord(domain, type));
        const results = await Promise.allSettled(promises);

        let currentFetchedRecords = [];
        let hasRecords = false;

        results.forEach((result) => {
          if (result.status === 'fulfilled' && result.value.data.Answer) {
            const records = result.value.data.Answer.map((ans) => ({
              name: ans.name || domain,
              type: ans.type ? getTypeString(ans.type) : result.value.type,
              data: ans.data,
              ttl: ans.TTL !== undefined ? ans.TTL : 'N/A'
            }));
            currentFetchedRecords.push(...records);
            if (records.length > 0) {
              hasRecords = true;
            }
          } else if (result.status === 'rejected') {
            console.warn(`Failed to fetch some record types: ${result.reason}`);
          }
        });

        if (!hasRecords) {
          showError(`No DNS records found for "${domain}". Try checking the domain spelling or try again later.`);
          return;
        }

        const domainSnapshots = getDomainSnapshots(appState.currentDomain);
        const previousSnapshot = domainSnapshots.length > 0 ? domainSnapshots[domainSnapshots.length - 1].records : null;

        let processedRecords;
        if (previousSnapshot && previousSnapshot.length > 0) {
          const comparisonResult = compareDnsRecords(currentFetchedRecords, previousSnapshot);
          processedRecords = [
            ...comparisonResult.added,
            ...comparisonResult.modified,
            ...comparisonResult.unchanged,
            ...comparisonResult.deleted
          ];
          processedRecords.sort((a, b) => {
            const typeOrder = RECORD_TYPES.indexOf(a.type) - RECORD_TYPES.indexOf(b.type);
            if (typeOrder !== 0) return typeOrder;
            const nameCompare = a.name.localeCompare(b.name);
            if (nameCompare !== 0) return nameCompare;
            const statusOrder = { added: 1, modified: 2, deleted: 3, unchanged: 4 };
            return statusOrder[a.status] - statusOrder[b.status];
          });
        } else {
          processedRecords = currentFetchedRecords.map((r) => ({ ...r, status: 'unchanged' }));
        }

        DOMElements.initialMessage.classList.add('hidden');
        DOMElements.resultsHeader.classList.add('flex');
        DOMElements.resultsHeader.classList.remove('hidden');

        updateState({ dnsRecords: processedRecords }, false); // Update state, then render below
        renderSections(appState.dnsRecords);


        try {
          saveDomainSnapshot(appState.currentDomain, currentFetchedRecords);
          saveDomainToHistory(domain);
        } catch (e) {
          showUserFeedback('Failed to save lookup history due to storage limitations.', 'warning');
        }

        updateState({ currentSnapshotIndex: getDomainSnapshots(appState.currentDomain).length - 1 }, false);
        populateHistoryDropdown(appState.currentDomain);
        updateHistoryDropdownSelection();
      } catch (err) {
        showError(`An unexpected error occurred: ${err.message}. Please try again.`);
      } finally {
        updateState({ isLoading: false });
      }
    }

    function getTypeString(typeNum) {
      switch (typeNum) {
        case 1: return 'A';
        case 28: return 'AAAA';
        case 5: return 'CNAME';
        case 15: return 'MX';
        case 2: return 'NS';
        case 16: return 'TXT';
        default: return `Type ${typeNum}`;
      }
    }

    function saveToLocalStorage(key, data) {
      try {
        localStorage.setItem(key, JSON.stringify(data));
      } catch (e) {
        if (e.name === 'QuotaExceededError') {
          showUserFeedback('Your browser storage is full. Some history or settings might not be saved.', 'warning');
        } else {
          showUserFeedback(`Failed to save data: ${e.message}`, 'error');
        }
        console.error(`Error saving ${key} to local storage:`, e);
        throw e; // Re-throw to allow further error handling if needed
      }
    }

    function loadFromLocalStorage(key, defaultValue = null) {
      try {
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : defaultValue;
      } catch (e) {
        showUserFeedback(`Failed to load data: ${e.message}`, 'error');
        console.error(`Error loading ${key} from local storage:`, e);
        return defaultValue;
      }
    }

    function loadSearchHistory() {
      return loadFromLocalStorage(LOCAL_STORAGE_HISTORY_KEY, []);
    }

    function saveDomainToHistory(domain) {
      let history = loadSearchHistory();
      history = history.filter((item) => item.toLowerCase() !== domain.toLowerCase());
      history.unshift(domain);
      history = history.slice(0, MAX_HISTORY_ITEMS);
      saveToLocalStorage(LOCAL_STORAGE_HISTORY_KEY, history);
    }

    function loadAllStoredRecords() {
      return loadFromLocalStorage(LOCAL_STORAGE_RECORDS_KEY, {});
    }

    function saveDomainSnapshot(domain, records) {
      let allStoredRecords = loadAllStoredRecords();
      const domainLower = domain.toLowerCase();

      if (!allStoredRecords[domainLower]) {
        allStoredRecords[domainLower] = [];
      }

      const newSnapshot = {
        timestamp: new Date().toISOString(),
        records: records
      };

      allStoredRecords[domainLower].push(newSnapshot);

      if (allStoredRecords[domainLower].length > MAX_SNAPSHOTS_PER_DOMAIN) {
        allStoredRecords[domainLower] = allStoredRecords[domainLower].slice(
          allStoredRecords[domainLower].length - MAX_SNAPSHOTS_PER_DOMAIN
        );
      }
      saveToLocalStorage(LOCAL_STORAGE_RECORDS_KEY, allStoredRecords);
    }

    function getDomainSnapshots(domain) {
      const allStoredRecords = loadAllStoredRecords();
      return allStoredRecords[domain.toLowerCase()] || [];
    }

    function createRecordId(record) {
      const dataToCompare = record.type === 'TXT' ? normalizeTxtData(record.data) : record.data;
      return `${record.name}||${record.type}||${dataToCompare}`;
    }

    function compareDnsRecords(currentRecords, previousRecords) {
      const added = [];
      const deleted = [];
      const modified = [];
      const unchanged = [];

      const previousMap = new Map();
      previousRecords.forEach((r) => previousMap.set(createRecordId(r), r));

      const previousNameTypeMap = new Map();
      previousRecords.forEach((r) => {
        const key = `${r.name}||${r.type}`;
        if (!previousNameTypeMap.has(key)) {
          previousNameTypeMap.set(key, []);
        }
        previousNameTypeMap.get(key).push(r);
      });

      currentRecords.forEach((currentRec) => {
        const currentId = createRecordId(currentRec);
        const nameTypeKey = `${currentRec.name}||${currentRec.type}`;

        if (previousMap.has(currentId)) {
          unchanged.push({ ...currentRec, status: 'unchanged' });
          previousMap.delete(currentId);
        } else {
          const potentialOldMatches = previousNameTypeMap.get(nameTypeKey);
          let isModified = false;

          if (potentialOldMatches) {
            for (let i = 0; i < potentialOldMatches.length; i++) {
              const oldRec = potentialOldMatches[i];
              const oldId = createRecordId(oldRec);
              if (previousMap.has(oldId)) {
                modified.push({
                  ...currentRec,
                  status: 'modified',
                  oldData: oldRec.data
                });
                previousMap.delete(oldId);
                isModified = true;
                break;
              }
            }
          }

          if (!isModified) {
            added.push({ ...currentRec, status: 'added' });
          }
        }
      });

      previousMap.forEach((oldRec) => {
        deleted.push({ ...oldRec, status: 'deleted' });
      });

      return { added, deleted, modified, unchanged };
    }

    function renderAutocompleteList(inputValue) {
      DOMElements.domainAutocompleteList.innerHTML = '';
      updateState({ currentAutocompleteFocus: -1 }, false);

      const history = loadSearchHistory();
      const filteredHistory = history.filter((item) =>
        item.toLowerCase().includes(inputValue.toLowerCase())
      );

      const itemsToShow = inputValue === '' ? history : filteredHistory;

      if (itemsToShow.length === 0) {
        hideAutocompleteList();
        return;
      }

      itemsToShow.forEach((item, index) => {
        const div = document.createElement('div');
        div.textContent = item;
        div.id = `autocomplete-item-${index}`; // Unique ID for ARIA
        div.setAttribute('role', 'option');
        div.setAttribute('aria-selected', 'false'); // Default
        DOMElements.domainAutocompleteList.appendChild(div);
      });
      DOMElements.domainAutocompleteList.classList.remove('hidden');
      DOMElements.domainInput.setAttribute('aria-expanded', 'true');
    }

    function hideAutocompleteList() {
      DOMElements.domainAutocompleteList.classList.add('hidden');
      updateState({ currentAutocompleteFocus: -1 }, false);
      const items = DOMElements.domainAutocompleteList.getElementsByTagName('div');
      for (let i = 0; i < items.length; i++) {
        items[i].classList.remove('autocomplete-active');
        items[i].setAttribute('aria-selected', 'false');
      }
      DOMElements.domainInput.removeAttribute('aria-activedescendant');
      DOMElements.domainInput.setAttribute('aria-expanded', 'false');
    }

    function addActive(items) {
      if (!items || items.length === 0) return;
      removeActive(items);
      let newFocus = appState.currentAutocompleteFocus;
      if (newFocus >= items.length) newFocus = 0;
      if (newFocus < 0) newFocus = items.length - 1;
      updateState({ currentAutocompleteFocus: newFocus }, false);

      items[appState.currentAutocompleteFocus].classList.add('autocomplete-active');
      items[appState.currentAutocompleteFocus].setAttribute('aria-selected', 'true');
      DOMElements.domainInput.setAttribute('aria-activedescendant', items[appState.currentAutocompleteFocus].id);
      items[appState.currentAutocompleteFocus].scrollIntoView({ block: 'nearest' });
    }

    function removeActive(items) {
      for (let i = 0; i < items.length; i++) {
        items[i].classList.remove('autocomplete-active');
        items[i].setAttribute('aria-selected', 'false');
      }
      DOMElements.domainInput.removeAttribute('aria-activedescendant');
    }

    function selectAutocompleteItem() {
      const items = DOMElements.domainAutocompleteList.getElementsByTagName('div');
      if (appState.currentAutocompleteFocus > -1 && items[appState.currentAutocompleteFocus]) {
        DOMElements.domainInput.value = items[appState.currentAutocompleteFocus].textContent;
        performDNSLookup(DOMElements.domainInput.value);
        hideAutocompleteList();
      } else if (DOMElements.domainInput.value) {
        performDNSLookup(DOMElements.domainInput.value);
        hideAutocompleteList(); // Hide even if not from list
      }
    }

    function populateHistoryDropdown(domain) {
      DOMElements.historySelectContainer.innerHTML = '';
      const domainSnapshots = getDomainSnapshots(domain);

      if (domainSnapshots.length <= 1) {
        DOMElements.historySelectContainer.classList.add('hidden');
        return;
      }

      DOMElements.historySelectContainer.classList.remove('hidden');

      const label = document.createElement('label');
      label.setAttribute('for', 'historySelect');
      label.className = 'text-sm font-medium text-[var(--text-primary)] sr-only';
      label.textContent = 'View historical DNS records';
      DOMElements.historySelectContainer.appendChild(label);

      const select = document.createElement('select');
      select.id = 'historySelect';
      select.className = 'filter-select min-w-[150px]';
      select.setAttribute('aria-label', 'Select a historical DNS record snapshot');
      select.setAttribute('data-action', 'select-history');

      const latestOption = document.createElement('option');
      latestOption.value = 'latest';
      latestOption.textContent = 'Latest Records';
      select.appendChild(latestOption);

      domainSnapshots.forEach((snapshot, index) => {
        const option = document.createElement('option');
        option.value = index;
        const date = new Date(snapshot.timestamp);
        option.textContent = `Snapshot: ${date.toLocaleString()}`;
        select.appendChild(option);
      });

      DOMElements.historySelectContainer.appendChild(select);
      updateHistoryDropdownSelection();
    }

    function updateHistoryDropdownSelection() {
      const historySelect = DOMElements.historySelectContainer.querySelector('#historySelect');
      if (historySelect) {
        const domainSnapshots = getDomainSnapshots(appState.currentDomain);
        if (appState.currentSnapshotIndex === domainSnapshots.length - 1) {
          historySelect.value = 'latest';
        } else if (appState.currentSnapshotIndex > -1) {
          historySelect.value = String(appState.currentSnapshotIndex);
        }
      }
    }

    function displaySelectedSnapshot(domain, snapshotIndex) {
      const domainSnapshots = getDomainSnapshots(domain);

      if (snapshotIndex < 0 || snapshotIndex >= domainSnapshots.length) {
        showError('Selected historical snapshot not found.');
        return;
      }

      const selectedSnapshot = domainSnapshots[snapshotIndex];
      const recordsToDisplay = selectedSnapshot.records;
      let previousSnapshotRecords = snapshotIndex > 0 ? domainSnapshots[snapshotIndex - 1].records : null;

      let processedRecords;
      if (previousSnapshotRecords) {
        const comparisonResult = compareDnsRecords(recordsToDisplay, previousSnapshotRecords);
        processedRecords = [
          ...comparisonResult.added,
          ...comparisonResult.modified,
          ...comparisonResult.unchanged,
          ...comparisonResult.deleted
        ];
        processedRecords.sort((a, b) => {
          const typeOrder = RECORD_TYPES.indexOf(a.type) - RECORD_TYPES.indexOf(b.type);
          if (typeOrder !== 0) return typeOrder;
          const nameCompare = a.name.localeCompare(b.name);
          if (nameCompare !== 0) return nameCompare;
          const statusOrder = { added: 1, modified: 2, deleted: 3, unchanged: 4 };
          return statusOrder[a.status] - statusOrder[b.status];
        });
      } else {
        processedRecords = recordsToDisplay.map((r) => ({ ...r, status: 'unchanged' }));
      }

      DOMElements.initialMessage.classList.add('hidden');
      DOMElements.resultsHeader.classList.add('flex');
      DOMElements.resultsHeader.classList.remove('hidden');
      DOMElements.historySelectContainer.classList.remove('hidden');
      DOMElements.exportBtn.classList.remove('hidden');

      updateState({
        dnsRecords: processedRecords,
        currentDomain: domain,
        currentSnapshotIndex: snapshotIndex
      });
    }

    function exportRecordsToTxt() {
      if (!appState.dnsRecords || appState.dnsRecords.length === 0) {
        showUserFeedback('No DNS records to export!', 'warning');
        return;
      }

      let fileContent = `DNS Records for ${appState.currentDomain || 'unknown-domain'}\n`;
      fileContent += `Generated on: ${new Date().toLocaleString()}\n\n`;

      const recordsByType = {};
      RECORD_TYPES.forEach((type) => {
        recordsByType[type] = appState.dnsRecords.filter((r) => r.type === type);
      });

      RECORD_TYPES.forEach((type) => {
        const records = recordsByType[type];
        if (records.length > 0) {
          fileContent += `--- ${type} Records (${records.length}) ---\n`;
          const sortedTypeRecords = sortRecords(records, 'name', 'asc');
          sortedTypeRecords.forEach((record) => {
            const status = record.status ? ` (${record.status})` : '';
            const oldData = record.status === 'modified' && record.oldData !== undefined
              ? ` (was: ${normalizeTxtData(record.oldData)})`
              : '';
            fileContent += `Name: ${record.name}\n`;
            fileContent += `Type: ${record.type}\n`;
            fileContent += `Data: ${normalizeTxtData(record.data)}${oldData}\n`;
            fileContent += `TTL: ${record.ttl}${status}\n`;
            fileContent += `---------------------------------\n`;
          });
          fileContent += `\n`;
        }
      });

      const filename = `dns_records_${appState.currentDomain.replace(/[^a-zA-Z0-9-.]/g, '_') || 'export'}.txt`;
      const blob = new Blob([fileContent], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showUserFeedback('DNS records exported successfully.', 'success');
    }

    // Theme management
    function setTheme(theme) {
      updateState({ theme }, false); // Update state, but let state management handle DOM for theme
      saveToLocalStorage(LOCAL_STORAGE_THEME_KEY, theme);
    }

    function toggleTheme() {
      const newTheme = appState.theme === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
    }

    function initializeTheme() {
      const savedTheme = loadFromLocalStorage(LOCAL_STORAGE_THEME_KEY);
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');
      setTheme(initialTheme);
    }

    // Debounce utility
    function debounce(func, wait) {
      return function (...args) {
        clearTimeout(appState.debounceTimeout);
        appState.debounceTimeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    // --- Event Delegation & Handlers ---
    document.addEventListener('click', (e) => {
      // Copyable elements
      const copyableElement = e.target.closest('.copyable');
      if (copyableElement) {
        e.stopPropagation();
        const text = copyableElement.getAttribute('data-copy');
        const field = copyableElement.getAttribute('aria-label').replace(/Copy DNS (name|data|TTL)(?::.*)?/, '$1');
        copyToClipboard(text, copyableElement, field);
      }

      // Autocomplete list items
      const autocompleteItem = e.target.closest('#domainAutocompleteList div');
      if (autocompleteItem) {
        DOMElements.domainInput.value = autocompleteItem.textContent;
        performDNSLookup(autocompleteItem.textContent);
        hideAutocompleteList();
        DOMElements.domainInput.focus();
        return; // Stop further processing for this click
      }

      // Hide autocomplete if clicked outside
      if (e.target !== DOMElements.domainInput && !DOMElements.domainAutocompleteList.contains(e.target)) {
        hideAutocompleteList();
      }

      // Details/Summary Toggle for ARIA
      const summaryElement = e.target.closest('summary');
      if (summaryElement) {
        const detailsElement = summaryElement.parentNode;
        if (detailsElement.tagName === 'DETAILS') {
            // The `open` attribute toggles first, then the event fires.
            // So, `detailsElement.open` will be the new state.
            summaryElement.setAttribute('aria-expanded', detailsElement.open ? 'true' : 'false');
        }
      }
    });

    document.addEventListener('keydown', (e) => {
      const items = DOMElements.domainAutocompleteList.getElementsByTagName('div');
      if (e.target === DOMElements.domainInput) {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          updateState({ currentAutocompleteFocus: appState.currentAutocompleteFocus + 1 }, false);
          addActive(items);
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          updateState({ currentAutocompleteFocus: appState.currentAutocompleteFocus - 1 }, false);
          addActive(items);
        } else if (e.key === 'Enter') {
          e.preventDefault();
          selectAutocompleteItem();
        } else if (e.key === 'Escape') {
          hideAutocompleteList();
        }
      }

      // Keyboard support for copyable and sortable elements
      const activeElement = document.activeElement;
      if (e.key === 'Enter' || e.key === ' ') {
        if (activeElement && activeElement.classList.contains('copyable')) {
          e.preventDefault();
          const text = activeElement.getAttribute('data-copy');
          const field = activeElement.getAttribute('aria-label').replace(/Copy DNS (name|data|TTL)(?::.*)?/, '$1');
          copyToClipboard(text, activeElement, field);
        } else if (activeElement && activeElement.tagName === 'TH' && activeElement.hasAttribute('data-sort')) {
          e.preventDefault();
          const column = activeElement.getAttribute('data-sort');
          const type = activeElement.getAttribute('data-type');
          let direction = 'asc';
          if (appState.currentSort[type] && appState.currentSort[type].column === column) {
            direction = appState.currentSort[type].direction === 'asc' ? 'desc' : 'asc';
          }
          appState.currentSort[type] = { column, direction }; // Update directly in state
          renderSections(appState.dnsRecords); // Re-render the relevant section
        } else if (activeElement && activeElement.tagName === 'SUMMARY') {
            // Let native details/summary handle space/enter for toggling
        } else if (activeElement && activeElement.id === 'lookupBtn') {
            e.preventDefault(); // Prevent default for space bar on button, enter already handled by form submission
            performDNSLookup(DOMElements.domainInput.value.trim());
        }
      }
    });

    DOMElements.domainInput.addEventListener('input', debounce(() => {
      const inputValue = DOMElements.domainInput.value.trim();
      renderAutocompleteList(inputValue);
    }, DEBOUNCE_DELAY));

    // Global delegation for other actions
    document.addEventListener('change', (e) => {
        if (e.target === DOMElements.filterType) {
            updateState({ filterType: e.target.value });
        } else if (e.target === DOMElements.themeToggle) {
            toggleTheme();
        } else if (e.target.dataset.action === 'select-history' && e.target.id === 'historySelect') {
            const selectedValue = e.target.value;
            let newSnapshotIndex;
            if (selectedValue === 'latest') {
              newSnapshotIndex = getDomainSnapshots(appState.currentDomain).length - 1;
            } else {
              newSnapshotIndex = parseInt(selectedValue, 10);
            }
            displaySelectedSnapshot(appState.currentDomain, newSnapshotIndex);
        }
    });

    DOMElements.lookupBtn.addEventListener('click', () => {
      performDNSLookup(DOMElements.domainInput.value.trim());
    });

    DOMElements.clearHistoryBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to clear all stored DNS history and records? This cannot be undone.')) {
        try {
          localStorage.clear();
          resetUI();
          showUserFeedback('All local storage data has been cleared.', 'success');
        } catch (e) {
          showUserFeedback('Failed to clear local storage.', 'error');
        }
      }
    });

    DOMElements.exportBtn.addEventListener('click', exportRecordsToTxt);


    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      initializeTheme();
      resetUI();
      const lastDomain = loadSearchHistory()[0];
      if (lastDomain) {
        DOMElements.domainInput.value = lastDomain;
      }
    });
  </script>
</body>
</html>
