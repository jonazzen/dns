<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DNS</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.tailwindcss.com"></script>
<style>
  :root {
    --bg-primary: #f5f7fa;
    --bg-secondary: #ffffff;
    --bg-tertiary: #e8ecef;
    --text-primary: #1a202c;
    --text-secondary: #4a5568;
    --border-color: #d1d5db;
    --hover-bg: #edf2ff;
    --table-header-bg: #f7fafc;
    --table-row-even: #f9fafb;
    --table-row-hover: #edf2ff;
    --tooltip-bg: #1a202c;
    --tooltip-text: #ffffff;
    --accent-blue: #3b82f6;
    --accent-blue-hover: #2563eb;
    --error-bg: #fef2f2;
    --error-text: #dc2626;
    --success-bg: #d1fae5;
    --success-text: #047857; /* Added for feedback */
    --warning-bg: #fef3c7;
    --warning-text: #d97706; /* Added for feedback */
    --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.05);
    --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
    --transition: all 0.3s ease;
    --font-size-base: clamp(14px, 2.5vw, 16px);
    --radius-md: 8px;
    --radius-sm: 4px;
  }

  /* ---------- Improved Dark Mode (keeps all required variables) ---------- */
  [data-theme="dark"] {
    /* Backgrounds */
    --bg-primary: #0d1117;       /* page background */
    --bg-secondary: #161b22;     /* cards, panels */
    --bg-tertiary: #1e2632;      /* accents, dark alternate */

    /* Text */
    --text-primary: #e6edf3;     /* primary copy (soft white) */
    --text-secondary: #9ca3af;   /* muted text */

    /* Borders & dividers */
    --border-color: #30363d;

    /* Hover / states */
    --hover-bg: #21262d;
    --table-header-bg: #1e2632;
    --table-row-even: #161b22;
    --table-row-hover: #2b3340;

    /* Tooltips (inverted for dark) */
    --tooltip-bg: #e6edf3;
    --tooltip-text: #0d1117;

    /* Accents */
    --accent-blue: #58a6ff;
    --accent-blue-hover: #1f6feb;

    /* Semantic */
    --error-bg: #2d0000;
    --error-text: #ff9b9b;
    --success-bg: #003d2e;
    --success-text: #5eead4;
    --warning-bg: #4d3b00;
    --warning-text: #fcd34d;

    /* Shadows (adjusted for dark mode, using variables) */
    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.4);
    --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.6);
  }

  /* subtle depth for dark theme panels - now using variables */
  [data-theme="dark"] .record-section,
  [data-theme="dark"] .header {
    box-shadow: var(--shadow-md);
    backdrop-filter: blur(3px);
  }

  /* make buttons pop in dark mode without changing layout */
  [data-theme="dark"] button:not(.btn-no-override),
  [data-theme="dark"] .btn:not(.btn-no-override) {
    background: var(--accent-blue);
    color: #fff;
    box-shadow: 0 0 8px rgba(88,166,255,0.18);
  }
  [data-theme="dark"] button:hover:not(.btn-no-override),
  [data-theme="dark"] .btn:hover:not(.btn-no-override) {
    background: var(--accent-blue-hover);
    box-shadow: 0 0 12px rgba(88,166,255,0.28);
  }


  /* === ORIGINAL / BASE STYLES (kept intact) === */
  body {
    font-family: 'Inter', sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    font-size: var(--font-size-base);
    transition: var(--transition);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  /* Layout */
  .container {
    max-width: 80rem;
    margin: 0 auto;
    padding: 1rem;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  /* Header */
  .header {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-md);
    padding: 1.5rem;
    box-shadow: var(--shadow-sm);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 1rem;
    transition: var(--transition);
  }

  /* Input Group */
  .input-group {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex-grow: 1;
    flex-wrap: wrap;
  }

  /* Record Section */
  .record-section {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-md);
    margin-bottom: 1rem;
    overflow: hidden;
    transition: var(--transition);
    box-shadow: var(--shadow-sm);
  }

  .record-section summary {
    padding: 0.75rem 1rem;
    background: var(--table-header-bg);
    font-weight: 600;
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: var(--transition);
  }

  .record-section summary:hover {
    background: var(--hover-bg);
  }

  .record-section summary::-webkit-details-marker {
    display: none;
  }

  .record-section summary::after {
    content: 'â–¼';
    font-size: 0.75rem;
    margin-left: auto;
    transition: transform 0.2s ease;
  }

  .record-section[open] summary::after {
    transform: rotate(180deg);
  }

  /* Table */
  .table-container {
    overflow-x: auto;
    padding: 1rem;
  }

  .dns-table {
    width: 100%;
    border-collapse: collapse;
  }

  .dns-table th,
  .dns-table td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid var(--border-color);
    color: var(--text-primary);
    font-size: var(--font-size-base);
  }

  .dns-table th {
    font-weight: 500;
    background: var(--table-header-bg);
    cursor: pointer;
    user-select: none;
    transition: var(--transition);
  }

  .dns-table th:hover {
    background: var(--hover-bg);
  }

  .dns-table tr:nth-child(even) {
    background: var(--table-row-even);
  }

  .dns-table tr:hover {
    background: var(--table-row-hover);
  }

  /* Sort Icon */
  .sort-icon {
    display: inline-block;
    width: 0.75rem;
    height: 0.75rem;
    margin-left: 0.25rem;
    vertical-align: middle;
    fill: var(--text-secondary);
    transition: var(--transition);
  }

  .sort-icon.asc {
    transform: rotate(180deg);
  }

  /* Copyable Elements */
  .copyable {
    cursor: pointer;
    position: relative;
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.5rem;
    border-radius: var(--radius-sm);
    transition: var(--transition);
  }

  .copyable:hover {
    background: var(--hover-bg);
    text-decoration: underline;
    text-decoration-color: var(--accent-blue);
  }

  .copy-icon {
    opacity: 0;
    margin-left: 0.25rem;
    width: 0.75rem;
    height: 0.75rem;
    fill: var(--accent-blue);
    transition: var(--transition);
  }

  .copyable:hover .copy-icon,
  .copyable:focus .copy-icon {
    opacity: 1;
  }

  .copyable.copied .copy-icon {
    opacity: 1;
    fill: #10b981;
    transform: scale(1.1);
  }

  .copy-tooltip {
    position: absolute;
    top: -2rem;
    left: 50%;
    transform: translateX(-50%);
    background: var(--tooltip-bg);
    color: var(--tooltip-text);
    padding: 0.25rem 0.5rem;
    border-radius: var(--radius-sm);
    font-size: 0.75rem;
    white-space: nowrap;
    pointer-events: none;
    z-index: 20;
    opacity: 0;
    transition: var(--transition);
    backdrop-filter: blur(4px);
  }

  .copyable:hover .copy-tooltip--hover,
  .copyable:focus .copy-tooltip--hover {
    opacity: 1;
  }

  .copyable.copied .copy-tooltip--copied {
    opacity: 1;
    top: -2rem;
  }

  /* Info Icon */
  .info-icon {
    position: relative;
    display: inline-block;
    width: 0.875rem;
    height: 0.875rem;
    margin-left: 0.25rem;
    fill: var(--text-secondary);
    cursor: pointer;
    vertical-align: middle;
    transition: var(--transition);
    z-index: 999;
  }

  .info-icon:hover,
  .info-icon:focus {
    transform: scale(1.1);
    fill: var(--accent-blue);
  }

  .info-tooltip {
    position: absolute;
    top: -2.5rem;
    left: 50%;
    transform: translateX(-50%);
    background: var(--tooltip-bg);
    color: var(--tooltip-text);
    padding: 0.25rem 0.5rem;
    border-radius: var(--radius-sm);
    font-size: 0.75rem;
    white-space: nowrap;
    pointer-events: none;
    z-index: 1000;
    opacity: 0;
    transition: var(--transition);
    backdrop-filter: blur(4px);
  }

  .info-icon:hover .info-tooltip,
  .info-icon:focus .info-tooltip {
    opacity: 1;
  }

  /* Loading Spinner */
  .loading-spinner {
    display: inline-block;
    width: 1rem;
    height: 1rem;
    border: 2px solid var(--tooltip-text);
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 0.5s linear infinite;
    margin-left: 0.5rem;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  /* Select */
  .filter-select {
    appearance: none;
    background: var(--table-header-bg);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-md);
    padding: 0.5rem 2rem 0.5rem 0.5rem;
    font-size: var(--font-size-base);
    color: var(--text-primary);
    cursor: pointer;
    transition: var(--transition);
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 1rem;
  }

  .filter-select:focus {
    outline: none;
    border-color: var(--accent-blue);
    box-shadow: 0 0 5px rgba(59, 130, 246, 0.2);
  }

  /* Input */
  .input-focus {
    transition: var(--transition);
    background: var(--bg-secondary);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-color);
  }

  .input-focus:focus {
    border-color: var(--accent-blue);
    box-shadow: 0 0 5px rgba(59, 130, 246, 0.2);
  }

  /* Icons */
  .search-icon {
    width: 1.125rem;
    height: 1.125rem;
    fill: var(--tooltip-text);
  }

  /* Record States */
  .record-row-added {
    background: var(--success-bg);
  }

  .record-row-deleted {
    background: var(--error-bg);
    text-decoration: line-through;
    opacity: 0.7;
  }

  .record-row-modified {
    background: var(--warning-bg);
  }

  .record-row-added:hover,
  .record-row-deleted:hover,
  .record-row-modified:hover {
    filter: brightness(95%);
  }

  /* Initial Message */
  .initial-message {
    text-align: center;
    padding: 2.5rem 1.25rem;
    color: var(--text-secondary);
    font-size: var(--font-size-base);
    line-height: 1.5;
    background: var(--table-header-bg);
    border-radius: var(--radius-md);
    border: 1px dashed var(--border-color);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: var(--transition);
    box-shadow: var(--shadow-sm);
  }

  .initial-message svg {
    width: 3rem;
    height: 3rem;
    fill: var(--text-secondary);
    margin-bottom: 1rem;
  }

  .initial-message p:first-child {
    font-weight: 600;
    margin-bottom: 0.5rem;
  }

  /* Autocomplete */
  #domainInputContainer {
    position: relative;
    flex-grow: 1;
  }

  #domainAutocompleteList {
    position: absolute;
    inset: 0 auto auto 0;
    border: 1px solid var(--border-color);
    border-top: none;
    z-index: 10;
    background: var(--bg-secondary);
    max-height: 12.5rem;
    overflow-y: auto;
    box-shadow: var(--shadow-md);
    border-radius: 0 0 var(--radius-md) var(--radius-md);
    transition: var(--transition);
    width: 100%; /* Ensure it spans the full width of its container */
  }

  #domainAutocompleteList div {
    padding: 0.625rem;
    cursor: pointer;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    color: var(--text-primary);
    transition: var(--transition);
  }

  #domainAutocompleteList div:last-child {
    border-bottom: none;
  }

  #domainAutocompleteList div:hover,
  #domainAutocompleteList div.autocomplete-active {
    background: var(--hover-bg);
  }

  /* Error Message (Deprecated in favor of userFeedbackContainer) */
  #error {
    display: none; /* Hidden */
  }

  /* User Feedback Container */
  #userFeedbackContainer {
    position: fixed;
    top: 1rem;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10000;
    width: clamp(20rem, 90%, 40rem);
    padding: 0.75rem 1.25rem;
    border-radius: var(--radius-md);
    box-shadow: var(--shadow-md);
    text-align: center;
    font-size: 0.95rem;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
  }

  #userFeedbackContainer.show {
    opacity: 1;
    visibility: visible;
  }

  #userFeedbackContainer.error {
    background: var(--error-bg);
    color: var(--error-text);
  }

  #userFeedbackContainer.warning {
    background: var(--warning-bg);
    color: var(--warning-text);
  }

  #userFeedbackContainer.success {
    background: var(--success-bg);
    color: var(--success-text);
  }


  /* Toggle Switch */
  .theme-toggle {
    position: relative;
    display: inline-block;
    width: 3rem;
    height: 1.5rem;
  }

  .theme-toggle input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .theme-toggle-slider {
    position: absolute;
    cursor: pointer;
    inset: 0;
    background: var(--table-header-bg);
    border: 1px solid var(--border-color);
    border-radius: 1rem;
    transition: var(--transition);
  }

  .theme-toggle-slider:before {
    position: absolute;
    content: "";
    height: 1.125rem;
    width: 1.125rem;
    left: 0.1875rem;
    bottom: 0.125rem;
    background: var(--text-primary);
    border-radius: 50%;
    transition: var(--transition);
  }

  .theme-toggle input:checked + .theme-toggle-slider {
    background: var(--accent-blue);
    border-color: var(--accent-blue);
  }

  .theme-toggle input:checked + .theme-toggle-slider:before {
    transform: translateX(1.5rem);
  }

  .theme-toggle input:focus + .theme-toggle-slider {
    box-shadow: 0 0 5px rgba(59, 130, 246, 0.2);
  }

  /* Footer */
  .footer {
    text-align: center;
    padding: 1rem 0;
    color: var(--text-secondary);
    font-size: 0.875rem;
  }

  /* ===========================
     MOBILE / RESPONSIVE ENHANCEMENTS
     Non-destructive: only active below breakpoints
     =========================== */

  /* Tablet and below: stack and make controls full-width for easy tapping */
  @media (max-width: 900px) {
    .container {
      padding: 0.75rem;
      gap: 1rem;
    }

    .header {
      flex-direction: column;
      align-items: stretch;
      padding: 1rem;
    }

    .input-group {
      flex-direction: column;
      width: 100%;
      gap: 0.75rem;
    }

    /* Make inputs/selects/buttons take full width on smaller viewports */
    input[type="text"],
    select.filter-select,
    .filter-select,
    .input-focus,
    button:not(.btn-no-override),
    .btn:not(.btn-no-override) {
      width: 100%;
      max-width: 100%;
      font-size: 1rem;
      box-sizing: border-box;
    }

    /* Larger comfortable tap targets */
    button:not(.btn-no-override),
    .btn:not(.btn-no-override),
    select,
    input {
      min-height: 44px; /* comfortable for most touch devices */
    }

    .table-container {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding: 0.5rem;
    }

    .dns-table th,
    .dns-table td {
      font-size: 0.95rem;
      padding: 0.6rem 0.75rem;
      white-space: nowrap;
    }

    .record-section summary {
      font-size: 1rem;
      padding: 0.75rem;
    }

    /* Tooltips: position below target on mobile to avoid clipping */
    .copy-tooltip,
    .info-tooltip {
      top: auto;
      bottom: -2rem;
      font-size: 0.75rem;
    }

    .initial-message {
      padding: 1.5rem 0.75rem;
      font-size: 0.95rem;
    }

    .footer {
      font-size: 0.8rem;
      padding: 0.5rem;
    }
  }

  /* Phones: tighten spacing slightly */
  @media (max-width: 480px) {
    body {
      font-size: 0.9rem;
    }

    .header {
      padding: 0.75rem;
    }

    .dns-table th,
    .dns-table td {
      padding: 0.4rem 0.5rem;
    }

    /* Ensure summary text and controls remain readable */
    .record-section summary {
      font-size: 0.95rem;
    }

    button:not(.btn-no-override),
    .btn:not(.btn-no-override) {
      padding: 0.6rem 0.75rem;
      font-size: 0.95rem;
      min-height: 44px;
    }
  }

  /* Reduce hover-based effects on touch-only devices (avoid odd UX) */
  @media (hover: none) {
    .copyable:hover,
    .info-icon:hover,
    .dns-table th:hover,
    .record-section summary:hover {
      background: none;
      transform: none;
    }
    .copyable:hover .copy-icon,
    .copyable:focus .copy-icon {
      opacity: 1;
    }
  }
</style>
</head>
<body>
  <div id="userFeedbackContainer" aria-live="assertive"></div>
  <div class="container">
    <div class="header">
      <h1 class="text-2xl font-semibold text-[var(--text-primary)]">
        DNS
      </h1>
      <div class="input-group">
        <div id="domainInputContainer">
          <input
            id="domainInput"
            type="text"
            placeholder="Enter domain (e.g., example.com)"
            class="input-focus w-full p-3 text-[var(--text-primary)]"
            aria-label="Domain name for DNS lookup"
            aria-autocomplete="list"
            aria-controls="domainAutocompleteList"
            autocomplete="off"
          />
          <div id="domainAutocompleteList" class="hidden" role="listbox"></div>
        </div>
      <button
          id="lookupBtn"
          aria-label="Search DNS records"
          class="bg-[var(--accent-blue)] text-[var(--tooltip-text)] rounded-full hover:bg-[var(--accent-blue-hover)] transition font-medium w-12 h-12 flex justify-center items-center flex-shrink-0"
        >
          <span id="lookupBtnText">
            <svg class="search-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 1 0-.7.7l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9z"></path></svg>
          </span>
        </button>
        <button
          id="clearHistoryBtn"
          aria-label="Clear all stored history and records"
          class="bg-red-600 text-white rounded-full hover:bg-red-700 transition font-medium w-12 h-12 flex justify-center items-center flex-shrink-0 btn-no-override"
          title="Clear all stored history and records"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
            class="w-5 h-5"
          >
            <path
              d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41z"
            />
          </svg>
        </button>
        <label class="theme-toggle" aria-label="Toggle dark/light mode">
          <input
            type="checkbox"
            id="themeToggle"
            role="switch"
            aria-checked="false"
          />
          <span class="theme-toggle-slider"></span>
        </label>
      </div>
    </div>
    <div id="result">
      <div id="initialMessage" class="initial-message">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"></path>
        </svg>
        <p>Start your DNS lookup</p>
        <p class="text-sm text-[var(--text-secondary)]">
          Enter a domain name above to retrieve its DNS records.
        </p>
      </div>
      <div
        id="resultsHeader"
        class="flex flex-col sm:flex-row justify-between items-center mb-4 hidden"
      >
        <h2 class="text-lg font-semibold text-[var(--text-primary)] mb-2 sm:mb-0">
          DNS Records for <span id="currentDomainDisplay"></span>
        </h2>
        <div class="flex flex-wrap gap-2 items-center">
          <select
            id="filterType"
            class="filter-select"
            aria-label="Filter by record type"
          >
            <option value="">All Types</option>
            <option value="A">A</option>
            <option value="AAAA">AAAA</option>
            <option value="CNAME">CNAME</option>
            <option value="MX">MX</option>
            <option value="NS">NS</option>
            <option value="TXT">TXT</option>
          </select>
          <button
            id="exportBtn"
            aria-label="Export DNS records to a text file"
            class="bg-green-600 text-white px-4 py-2 rounded-[var(--radius-md)] hover:bg-green-700 transition font-medium hidden btn-no-override"
            title="Export Records"
          >
            Export .TXT
          </button>
        </div>
      </div>
      <div id="historySelectContainer" class="flex items-center gap-2 mb-4 hidden"></div>
      <div id="resultSections"></div>
    </div>
    <div
      id="error"
      class="mt-4 hidden"
    ></div>
    <div class="footer">
      <small>
        <b>DNS</b> Version: <b>1.3.80</b>
      </small>
    </div>
    <div aria-live="polite" class="sr-only" id="copy-status"></div>
  </div>
  <script>
    // DOM elements
    const DOMElements = {
      lookupBtn: document.getElementById('lookupBtn'),
      lookupBtnText: document.getElementById('lookupBtnText'),
      domainInput: document.getElementById('domainInput'),
      domainInputContainer: document.getElementById('domainInputContainer'),
      domainAutocompleteList: document.getElementById('domainAutocompleteList'),
      resultDiv: document.getElementById('result'),
      resultSections: document.getElementById('resultSections'),
      errorDiv: document.getElementById('error'), // Deprecated, but kept for removal clarity
      filterType: document.getElementById('filterType'),
      copyStatus: document.getElementById('copy-status'),
      initialMessage: document.getElementById('initialMessage'),
      resultsHeader: document.getElementById('resultsHeader'),
      clearHistoryBtn: document.getElementById('clearHistoryBtn'),
      exportBtn: document.getElementById('exportBtn'),
      themeToggle: document.getElementById('themeToggle'),
      userFeedbackContainer: document.getElementById('userFeedbackContainer'),
      currentDomainDisplay: document.getElementById('currentDomainDisplay'),
      historySelectContainer: document.getElementById('historySelectContainer'), // Initialized later
    };

    // Constants
    const RECORD_TYPES = ['A', 'AAAA', 'CNAME', 'MX', 'NS', 'TXT'];
    const API_URL = 'https://1.1.1.1/dns-query';
    const LOCAL_STORAGE_HISTORY_KEY = 'dnsLookupHistory';
    const LOCAL_STORAGE_RECORDS_KEY = 'dnsStoredRecords';
    const LOCAL_STORAGE_THEME_KEY = 'dnsTheme';
    const MAX_HISTORY_ITEMS = 10;
    const MAX_SNAPSHOTS_PER_DOMAIN = 5;
    const DEBOUNCE_DELAY = 300;
    const FEEDBACK_DISPLAY_TIME = 4000; // Time in ms to show user feedback

    // State (centralized)
    const appState = {
      dnsRecords: [],
      currentSort: {}, // { 'A': {column: 'name', direction: 'asc'}, ... }
      currentAutocompleteFocus: -1,
      currentDomain: '',
      currentSnapshotIndex: -1,
      debounceTimeout: null,
      theme: 'light',
      isLoading: false,
    };

    // SVG icons
    const SVGS = {
      copy: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>`,
      checkmark: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>`,
      info: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-10h-2v6h-2zm0-4h-2v2h2V6z"/></svg>`,
      sort: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z"/></svg>`,
      search: `<svg class="search-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 1 0-.7.7l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9z"/></svg>`
    };

    const RECORD_DESCRIPTIONS = {
      A: 'Maps a domain to an IPv4 address (e.g., 192.0.2.1)',
      AAAA: 'Maps a domain to an IPv6 address (e.g., 2001:db8::1)',
      CNAME: 'Aliases one domain to another (e.g., www.example.com to example.com)',
      MX: 'Specifies mail servers for the domain (e.g., mail.example.com) with a preference value.',
      NS: 'Defines authoritative nameservers for the domain. Crucial for delegation.',
      TXT: 'Stores arbitrary text data, often for verification (e.g., SPF, DKIM, DMARC) or general info.'
    };

    let userFeedbackTimeout;
    function showUserFeedback(message, type = 'info', duration = FEEDBACK_DISPLAY_TIME) {
      clearTimeout(userFeedbackTimeout);
      const feedbackDiv = DOMElements.userFeedbackContainer;
      feedbackDiv.textContent = message;
      feedbackDiv.className = ``; // Reset classes
      feedbackDiv.classList.add('show', type);
      userFeedbackTimeout = setTimeout(() => {
        feedbackDiv.classList.remove('show');
      }, duration);
    }


    // --- State Management and UI Update ---
    function updateState(newState, reRender = true) {
      Object.assign(appState, newState);
      if (!reRender) return;

      if (newState.currentDomain !== undefined) {
        DOMElements.currentDomainDisplay.textContent = appState.currentDomain;
        populateHistoryDropdown(appState.currentDomain);
      }
      if (newState.dnsRecords !== undefined || newState.filterType !== undefined || newState.currentSort !== undefined) {
        renderSections(appState.dnsRecords);
      }
      if (newState.isLoading !== undefined) {
        DOMElements.lookupBtn.disabled = appState.isLoading;
        DOMElements.domainInput.disabled = appState.isLoading;
        DOMElements.filterType.disabled = appState.isLoading;
        DOMElements.exportBtn.disabled = appState.isLoading;
        DOMElements.lookupBtnText.innerHTML = appState.isLoading ? `<span class="loading-spinner"></span>` : SVGS.search;
      }
      if (newState.theme !== undefined) {
          document.documentElement.setAttribute('data-theme', appState.theme);
          DOMElements.themeToggle.checked = appState.theme === 'dark';
          DOMElements.themeToggle.setAttribute('aria-checked', appState.theme === 'dark');
      }
    }

    // Utility functions
    function escapeHtmlAttribute(value) {
      if (value === null || value === undefined) return '';
      return String(value)
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function normalizeTxtData(data) {
      if (Array.isArray(data)) {
        return data.join(' ').replace(/^"(.*)"$/, '$1').replace(/\s+/g, ' ').trim();
      }
      if (typeof data === 'string') {
        return data.replace(/^"(.*)"$/, '$1').replace(/\s+/g, ' ').trim();
      }
      return String(data).replace(/^"(.*)"$/, '$1').replace(/\s+/g, ' ').trim();
    }

    function isValidDomain(domain) {
      const domainRegex =
        /^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
      return (
        domainRegex.test(domain) &&
        domain.length <= 253 &&
        !domain.includes('..') &&
        !domain.startsWith('-') &&
        !domain.endsWith('-')
      );
    }

    function showError(message) {
      console.error('Error:', message);
      showUserFeedback(message, 'error');
      DOMElements.initialMessage.classList.add('hidden');
      DOMElements.resultsHeader.classList.add('hidden');
      DOMElements.historySelectContainer.classList.add('hidden');
      DOMElements.exportBtn.classList.add('hidden');
      DOMElements.resultSections.innerHTML = '';
    }

    function resetUI() {
      showUserFeedback('', 'info', 0); // Clear any existing feedback
      DOMElements.resultSections.innerHTML = '';
      updateState({
        dnsRecords: [],
        currentAutocompleteFocus: -1,
        currentDomain: '',
        currentSnapshotIndex: -1,
        isLoading: false,
      }, false); // Don't re-render everything on reset, will be done selectively
      DOMElements.filterType.value = '';
      DOMElements.initialMessage.classList.remove('hidden');
      DOMElements.resultsHeader.classList.add('hidden');
      DOMElements.historySelectContainer.classList.add('hidden');
      DOMElements.exportBtn.classList.add('hidden');
      RECORD_TYPES.forEach((type) => {
        appState.currentSort[type] = { column: 'name', direction: 'asc' };
      });
      hideAutocompleteList();
      DOMElements.domainInput.value = '';
      DOMElements.currentDomainDisplay.textContent = '';
    }

    async function copyToClipboard(text, element, field) {
      const announceStatus = (message) => {
        DOMElements.copyStatus.textContent = message;
        setTimeout(() => {
          DOMElements.copyStatus.textContent = '';
        }, 3000);
      };
      try {
        await navigator.clipboard.writeText(text);
        element.classList.add('copied');
        element.querySelector('.copy-icon').innerHTML = SVGS.checkmark;
        announceStatus(`Copied ${field} to clipboard.`);
        setTimeout(() => {
          element.classList.remove('copied');
          element.querySelector('.copy-icon').innerHTML = SVGS.copy;
        }, 2000);
      } catch (err) {
        console.error(`Clipboard API failed for ${field}:`, err);
        announceStatus('Failed to copy: Please grant clipboard access or try again.');
        try {
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand('copy');
          document.body.removeChild(textarea);
          element.classList.add('copied');
          element.querySelector('.copy-icon').innerHTML = SVGS.checkmark;
          announceStatus(`Copied ${field} to clipboard (fallback).`);
          setTimeout(() => {
            element.classList.remove('copied');
            element.querySelector('.copy-icon').innerHTML = SVGS.copy;
          }, 2000);
        } catch (fallbackErr) {
          console.error(`Fallback copy failed for ${field}:`, fallbackErr);
          announceStatus('Failed to copy: Your browser does not support clipboard operations.');
        }
      }
    }

    function sortRecords(records, column, direction) {
      const statusOrder = {
        added: 1,
        modified: 2,
        deleted: 3,
        unchanged: 4,
        undefined: 5
      };

      return [...records].sort((a, b) => {
        const statusCompare = statusOrder[a.status] - statusOrder[b.status];
        if (statusCompare !== 0) return statusCompare;

        let valueA = a[column];
        let valueB = b[column];

        if (column === 'data') {
          valueA = a.type === 'TXT' ? normalizeTxtData(valueA) : String(valueA);
          valueB = b.type === 'TXT' ? normalizeTxtData(valueB) : String(valueB);
        } else if (column === 'ttl') {
          valueA = parseInt(a.ttl, 10) || 0;
          valueB = parseInt(b.ttl, 10) || 0;
        } else {
          valueA = String(valueA).toLowerCase();
          valueB = String(valueB).toLowerCase();
        }

        if (valueA < valueB) return direction === 'asc' ? -1 : 1;
        if (valueA > valueB) return direction === 'asc' ? 1 : -1;
        return 0;
      });
    }

    function renderTable(records, type) {
      if (!records || records.length === 0) {
        return `<p class="text-center text-[var(--text-secondary)] py-4">No ${type} records found.</p>`;
      }
      const sortCol = appState.currentSort[type].column;
      const sortDir = appState.currentSort[type].direction;
      const sortedRecords = sortRecords(records, sortCol, sortDir);
      let html = `
        <div class="table-container">
          <table class="dns-table" role="table" aria-label="${type} DNS Records">
            <thead>
              <tr>
                <th scope="col" data-sort="name" data-type="${type}" tabindex="0" aria-sort="${
                  sortCol === 'name' ? (sortDir === 'asc' ? 'ascending' : 'descending') : 'none'
                }">Name <span class="sort-icon ${sortCol === 'name' && sortDir === 'asc' ? 'asc' : ''}">${
                  sortCol === 'name' ? SVGS.sort : ''
                }</span></th>
                <th scope="col" data-sort="data" data-type="${type}" tabindex="0" aria-sort="${
                  sortCol === 'data' ? (sortDir === 'asc' ? 'ascending' : 'descending') : 'none'
                }">Data <span class="sort-icon ${sortCol === 'data' && sortDir === 'asc' ? 'asc' : ''}">${
                  sortCol === 'data' ? SVGS.sort : ''
                }</span></th>
                <th scope="col" data-sort="ttl" data-type="${type}" tabindex="0" aria-sort="${
                  sortCol === 'ttl' ? (sortDir === 'asc' ? 'ascending' : 'descending') : 'none'
                }">TTL <span class="sort-icon ${sortCol === 'ttl' && sortDir === 'asc' ? 'asc' : ''}">${
                  sortCol === 'ttl' ? SVGS.sort : ''
                }</span></th>
              </tr>
            </thead>
            <tbody>
      `;
      sortedRecords.forEach((record) => {
        const normalizedData = record.type === 'TXT' ? normalizeTxtData(record.data) : record.data;
        const normalizedTTL = record.ttl !== 'N/A' ? String(record.ttl) : 'N/A';
        const rowClass = record.status && ['added', 'modified', 'deleted'].includes(record.status)
          ? `record-row-${record.status}`
          : '';

        let oldDataDisplay = '';
        if (record.status === 'modified' && record.oldData !== undefined) {
          const oldNormalizedData = record.type === 'TXT' ? normalizeTxtData(record.oldData) : record.oldData;
          oldDataDisplay = `<span class="text-[var(--text-secondary)] text-xs ml-1">(was: ${escapeHtmlAttribute(oldNormalizedData)})</span>`;
        }

        let statusIndicator = '';
        if (record.status === 'added') {
          statusIndicator = '<span class="text-green-600 text-xs font-semibold ml-1">(New)</span>';
        } else if (record.status === 'modified') {
          statusIndicator = '<span class="text-yellow-600 text-xs font-semibold ml-1">(Changed)</span>';
        } else if (record.status === 'deleted') {
          statusIndicator = '<span class="text-red-600 text-xs font-semibold ml-1">(Deleted)</span>';
        } else if (record.status === 'unchanged' && appState.currentSnapshotIndex > -1) {
          statusIndicator = '<span class="text-[var(--text-secondary)] text-xs font-semibold ml-1">(Unchanged)</span>';
        }

        html += `
          <tr class="${rowClass}">
            <td role="cell">
              <span class="copyable" role="button" tabindex="0" data-copy="${escapeHtmlAttribute(record.name)}" aria-label="Copy DNS name: ${escapeHtmlAttribute(record.name)}">
                ${escapeHtmlAttribute(record.name)}
                ${statusIndicator}
                <span class="copy-icon">${SVGS.copy}</span>
                <span class="copy-tooltip copy-tooltip--hover">Copy</span>
                <span class="copy-tooltip copy-tooltip--copied">Copied!</span>
              </span>
            </td>
            <td role="cell">
              <span class="copyable" role="button" tabindex="0" data-copy="${escapeHtmlAttribute(normalizedData)}" aria-label="Copy DNS data: ${escapeHtmlAttribute(normalizedData)}">
                ${escapeHtmlAttribute(normalizedData)}
                ${oldDataDisplay}
                <span class="copy-icon">${SVGS.copy}</span>
                <span class="copy-tooltip copy-tooltip--hover">Copy</span>
                <span class="copy-tooltip copy-tooltip--copied">Copied!</span>
              </span>
            </td>
            <td role="cell">
              <span class="copyable" role="button" tabindex="0" data-copy="${escapeHtmlAttribute(normalizedTTL)}" aria-label="Copy DNS TTL: ${escapeHtmlAttribute(normalizedTTL)}">
                ${normalizedTTL}
                <span class="copy-icon">${SVGS.copy}</span>
                <span class="copy-tooltip copy-tooltip--hover">Copy</span>
                <span class="copy-tooltip copy-tooltip--copied">Copied!</span>
              </span>
            </td>
          </tr>
        `;
      });
      html += `
            </tbody>
          </table>
        </div>
      `;
      return html;
    }

    function renderSections(records) {
      DOMElements.resultSections.innerHTML = '';
      const filterValue = DOMElements.filterType.value;
      let anySectionsRendered = false;

      RECORD_TYPES.forEach((type) => {
        const typeRecords = records.filter((record) => record.type === type);
        if (filterValue && filterValue !== type) return;

        if (!appState.currentSort[type]) {
          appState.currentSort[type] = { column: 'name', direction: 'asc' };
        }
        const currentTypeSort = appState.currentSort[type];

        if (typeRecords.length === 0) return;

        anySectionsRendered = true;
        const sectionId = `section-${type}`;
        const section = document.createElement('details');
        section.className = 'record-section';
        section.id = sectionId;
        section.open = true;
        section.setAttribute('role', 'group');
        section.setAttribute('aria-labelledby', `${sectionId}-summary`);

        // Dynamically create summary element for ARIA
        const summary = document.createElement('summary');
        summary.id = `${sectionId}-summary`;
        summary.setAttribute('aria-expanded', 'true');
        summary.setAttribute('aria-controls', `${sectionId}-content`);
        summary.innerHTML = `
            ${type} Records
            <span class="info-icon" tabindex="0" role="button" aria-label="Learn about ${type} records">
              ${SVGS.info}
              <span class="info-tooltip">${RECORD_DESCRIPTIONS[type] || 'No description available.'}</span>
            </span>
            <span class="record-count">(${typeRecords.length})</span>
        `;
        section.appendChild(summary);

        const contentDiv = document.createElement('div');
        contentDiv.id = `${sectionId}-content`;
        contentDiv.innerHTML = renderTable(typeRecords, type);
        section.appendChild(contentDiv);
        
        DOMElements.resultSections.appendChild(section);
      });

      if (!anySectionsRendered) {
        DOMElements.resultSections.innerHTML = `
          <div class="initial-message">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/>
            </svg>
            <p>No DNS records found for the applied filter.</p>
            <p class="text-sm text-[var(--text-secondary)]">Try adjusting your filter or searching for a different domain.</p>
          </div>
        `;
        DOMElements.initialMessage.classList.add('hidden');
        DOMElements.exportBtn.classList.add('hidden');
      } else {
        DOMElements.exportBtn.classList.remove('hidden');
      }
    }


    async function fetchDNSRecord(domain, type) {
      try {
        const response = await fetch(
          `${API_URL}?name=${encodeURIComponent(domain)}&type=${type}`,
          { headers: { Accept: 'application/dns-json' } }
        );
        if (!response.ok) {
          throw new Error(`DNS query failed for ${type} records: HTTP ${response.status} - ${response.statusText}`);
        }
        const data = await response.json();
        return { type, data };
      } catch (error) {
        console.error(`Fetch error for ${type} record type:`, error);
        return { type, data: { Status: -1, Comment: error.message, Answer: [] } };
      }
    }

    async function performDNSLookup(domain) {
      if (appState.isLoading) return; // Prevent multiple lookups
      if (!domain) {
        showError('Please enter a domain name.');
        return;
      }
      resetUI();
      updateState({ isLoading: true, currentDomain: domain.toLowerCase() });

      try {
        if (!isValidDomain(domain)) {
          showError('Please enter a valid domain name (e.g., example.com).');
          return;
        }

        const promises = RECORD_TYPES.map((type) => fetchDNSRecord(domain, type));
        const results = await Promise.allSettled(promises);

        let currentFetchedRecords = [];
        let hasRecords = false;

        results.forEach((result) => {
          if (result.status === 'fulfilled' && result.value.data.Answer) {
            const records = result.value.data.Answer.map((ans) => ({
              name: ans.name || domain,
              type: ans.type ? getTypeString(ans.type) : result.value.type,
              data: ans.data,
              ttl: ans.TTL !== undefined ? ans.TTL : 'N/A'
            }));
            currentFetchedRecords.push(...records);
            if (records.length > 0) {
              hasRecords = true;
            }
          } else if (result.status === 'rejected') {
            console.warn(`Failed to fetch some record types: ${result.reason}`);
          }
        });

        if (!hasRecords) {
          showError(`No DNS records found for "${domain}". Try checking the domain spelling or try again later.`);
          return;
        }

        const domainSnapshots = getDomainSnapshots(appState.currentDomain);
        const previousSnapshot = domainSnapshots.length > 0 ? domainSnapshots[domainSnapshots.length - 1].records : null;

        let processedRecords;
        if (previousSnapshot && previousSnapshot.length > 0) {
          const comparisonResult = compareDnsRecords(currentFetchedRecords, previousSnapshot);
          processedRecords = [
            ...comparisonResult.added,
            ...comparisonResult.modified,
            ...comparisonResult.unchanged,
            ...comparisonResult.deleted
          ];
          processedRecords.sort((a, b) => {
            const typeOrder = RECORD_TYPES.indexOf(a.type) - RECORD_TYPES.indexOf(b.type);
            if (typeOrder !== 0) return typeOrder;
            const nameCompare = a.name.localeCompare(b.name);
            if (nameCompare !== 0) return nameCompare;
            const statusOrder = { added: 1, modified: 2, deleted: 3, unchanged: 4 };
            return statusOrder[a.status] - statusOrder[b.status];
          });
        } else {
          processedRecords = currentFetchedRecords.map((r) => ({ ...r, status: 'unchanged' }));
        }

        DOMElements.initialMessage.classList.add('hidden');
        DOMElements.resultsHeader.classList.add('flex');
        DOMElements.resultsHeader.classList.remove('hidden');

        updateState({ dnsRecords: processedRecords }, false); // Update state, then render below
        renderSections(appState.dnsRecords);


        try {
          saveDomainSnapshot(appState.currentDomain, currentFetchedRecords);
          saveDomainToHistory(domain);
        } catch (e) {
          showUserFeedback('Failed to save lookup history due to storage limitations.', 'warning');
        }

        updateState({ currentSnapshotIndex: getDomainSnapshots(appState.currentDomain).length - 1 }, false);
        populateHistoryDropdown(appState.currentDomain);
        updateHistoryDropdownSelection();
      } catch (err) {
        showError(`An unexpected error occurred: ${err.message}. Please try again.`);
      } finally {
        updateState({ isLoading: false });
      }
    }

    function getTypeString(typeNum) {
      switch (typeNum) {
        case 1: return 'A';
        case 28: return 'AAAA';
        case 5: return 'CNAME';
        case 15: return 'MX';
        case 2: return 'NS';
        case 16: return 'TXT';
        default: return `Type ${typeNum}`;
      }
    }

    function saveToLocalStorage(key, data) {
      try {
        localStorage.setItem(key, JSON.stringify(data));
      } catch (e) {
        if (e.name === 'QuotaExceededError') {
          showUserFeedback('Your browser storage is full. Some history or settings might not be saved.', 'warning');
        } else {
          showUserFeedback(`Failed to save data: ${e.message}`, 'error');
        }
        console.error(`Error saving ${key} to local storage:`, e);
        throw e; // Re-throw to allow further error handling if needed
      }
    }

    function loadFromLocalStorage(key, defaultValue = null) {
      try {
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : defaultValue;
      } catch (e) {
        showUserFeedback(`Failed to load data: ${e.message}`, 'error');
        console.error(`Error loading ${key} from local storage:`, e);
        return defaultValue;
      }
    }

    function loadSearchHistory() {
      return loadFromLocalStorage(LOCAL_STORAGE_HISTORY_KEY, []);
    }

    function saveDomainToHistory(domain) {
      let history = loadSearchHistory();
      history = history.filter((item) => item.toLowerCase() !== domain.toLowerCase());
      history.unshift(domain);
      history = history.slice(0, MAX_HISTORY_ITEMS);
      saveToLocalStorage(LOCAL_STORAGE_HISTORY_KEY, history);
    }

    function loadAllStoredRecords() {
      return loadFromLocalStorage(LOCAL_STORAGE_RECORDS_KEY, {});
    }

    function saveDomainSnapshot(domain, records) {
      let allStoredRecords = loadAllStoredRecords();
      const domainLower = domain.toLowerCase();

      if (!allStoredRecords[domainLower]) {
        allStoredRecords[domainLower] = [];
      }

      const newSnapshot = {
        timestamp: new Date().toISOString(),
        records: records
      };

      allStoredRecords[domainLower].push(newSnapshot);

      if (allStoredRecords[domainLower].length > MAX_SNAPSHOTS_PER_DOMAIN) {
        allStoredRecords[domainLower] = allStoredRecords[domainLower].slice(
          allStoredRecords[domainLower].length - MAX_SNAPSHOTS_PER_DOMAIN
        );
      }
      saveToLocalStorage(LOCAL_STORAGE_RECORDS_KEY, allStoredRecords);
    }

    function getDomainSnapshots(domain) {
      const allStoredRecords = loadAllStoredRecords();
      return allStoredRecords[domain.toLowerCase()] || [];
    }

    function createRecordId(record) {
      const dataToCompare = record.type === 'TXT' ? normalizeTxtData(record.data) : record.data;
      return `${record.name}||${record.type}||${dataToCompare}`;
    }

    function compareDnsRecords(currentRecords, previousRecords) {
      const added = [];
      const deleted = [];
      const modified = [];
      const unchanged = [];

      const previousMap = new Map();
      previousRecords.forEach((r) => previousMap.set(createRecordId(r), r));

      const previousNameTypeMap = new Map();
      previousRecords.forEach((r) => {
        const key = `${r.name}||${r.type}`;
        if (!previousNameTypeMap.has(key)) {
          previousNameTypeMap.set(key, []);
        }
        previousNameTypeMap.get(key).push(r);
      });

      currentRecords.forEach((currentRec) => {
        const currentId = createRecordId(currentRec);
        const nameTypeKey = `${currentRec.name}||${currentRec.type}`;

        if (previousMap.has(currentId)) {
          unchanged.push({ ...currentRec, status: 'unchanged' });
          previousMap.delete(currentId);
        } else {
          const potentialOldMatches = previousNameTypeMap.get(nameTypeKey);
          let isModified = false;

          if (potentialOldMatches) {
            for (let i = 0; i < potentialOldMatches.length; i++) {
              const oldRec = potentialOldMatches[i];
              const oldId = createRecordId(oldRec);
              if (previousMap.has(oldId)) {
                modified.push({
                  ...currentRec,
                  status: 'modified',
                  oldData: oldRec.data
                });
                previousMap.delete(oldId);
                isModified = true;
                break;
              }
            }
          }

          if (!isModified) {
            added.push({ ...currentRec, status: 'added' });
          }
        }
      });

      previousMap.forEach((oldRec) => {
        deleted.push({ ...oldRec, status: 'deleted' });
      });

      return { added, deleted, modified, unchanged };
    }

    function renderAutocompleteList(inputValue) {
      DOMElements.domainAutocompleteList.innerHTML = '';
      updateState({ currentAutocompleteFocus: -1 }, false);

      const history = loadSearchHistory();
      const filteredHistory = history.filter((item) =>
        item.toLowerCase().includes(inputValue.toLowerCase())
      );

      const itemsToShow = inputValue === '' ? history : filteredHistory;

      if (itemsToShow.length === 0) {
        hideAutocompleteList();
        return;
      }

      itemsToShow.forEach((item, index) => {
        const div = document.createElement('div');
        div.textContent = item;
        div.id = `autocomplete-item-${index}`; // Unique ID for ARIA
        div.setAttribute('role', 'option');
        div.setAttribute('aria-selected', 'false'); // Default
        DOMElements.domainAutocompleteList.appendChild(div);
      });
      DOMElements.domainAutocompleteList.classList.remove('hidden');
      DOMElements.domainInput.setAttribute('aria-expanded', 'true');
    }

    function hideAutocompleteList() {
      DOMElements.domainAutocompleteList.classList.add('hidden');
      updateState({ currentAutocompleteFocus: -1 }, false);
      const items = DOMElements.domainAutocompleteList.getElementsByTagName('div');
      for (let i = 0; i < items.length; i++) {
        items[i].classList.remove('autocomplete-active');
        items[i].setAttribute('aria-selected', 'false');
      }
      DOMElements.domainInput.removeAttribute('aria-activedescendant');
      DOMElements.domainInput.setAttribute('aria-expanded', 'false');
    }

    function addActive(items) {
      if (!items || items.length === 0) return;
      removeActive(items);
      let newFocus = appState.currentAutocompleteFocus;
      if (newFocus >= items.length) newFocus = 0;
      if (newFocus < 0) newFocus = items.length - 1;
      updateState({ currentAutocompleteFocus: newFocus }, false);

      items[appState.currentAutocompleteFocus].classList.add('autocomplete-active');
      items[appState.currentAutocompleteFocus].setAttribute('aria-selected', 'true');
      DOMElements.domainInput.setAttribute('aria-activedescendant', items[appState.currentAutocompleteFocus].id);
      items[appState.currentAutocompleteFocus].scrollIntoView({ block: 'nearest' });
    }

    function removeActive(items) {
      for (let i = 0; i < items.length; i++) {
        items[i].classList.remove('autocomplete-active');
        items[i].setAttribute('aria-selected', 'false');
      }
      DOMElements.domainInput.removeAttribute('aria-activedescendant');
    }

    function selectAutocompleteItem() {
      const items = DOMElements.domainAutocompleteList.getElementsByTagName('div');
      if (appState.currentAutocompleteFocus > -1 && items[appState.currentAutocompleteFocus]) {
        DOMElements.domainInput.value = items[appState.currentAutocompleteFocus].textContent;
        performDNSLookup(DOMElements.domainInput.value);
        hideAutocompleteList();
      } else if (DOMElements.domainInput.value) {
        performDNSLookup(DOMElements.domainInput.value);
        hideAutocompleteList(); // Hide even if not from list
      }
    }

    function populateHistoryDropdown(domain) {
      DOMElements.historySelectContainer.innerHTML = '';
      const domainSnapshots = getDomainSnapshots(domain);

      if (domainSnapshots.length <= 1) {
        DOMElements.historySelectContainer.classList.add('hidden');
        return;
      }

      DOMElements.historySelectContainer.classList.remove('hidden');

      const label = document.createElement('label');
      label.setAttribute('for', 'historySelect');
      label.className = 'text-sm font-medium text-[var(--text-primary)] sr-only';
      label.textContent = 'View historical DNS records';
      DOMElements.historySelectContainer.appendChild(label);

      const select = document.createElement('select');
      select.id = 'historySelect';
      select.className = 'filter-select min-w-[150px]';
      select.setAttribute('aria-label', 'Select a historical DNS record snapshot');
      select.setAttribute('data-action', 'select-history');

      const latestOption = document.createElement('option');
      latestOption.value = 'latest';
      latestOption.textContent = 'Latest Records';
      select.appendChild(latestOption);

      domainSnapshots.forEach((snapshot, index) => {
        const option = document.createElement('option');
        option.value = index;
        const date = new Date(snapshot.timestamp);
        option.textContent = `Snapshot: ${date.toLocaleString()}`;
        select.appendChild(option);
      });

      DOMElements.historySelectContainer.appendChild(select);
      updateHistoryDropdownSelection();
    }

    function updateHistoryDropdownSelection() {
      const historySelect = DOMElements.historySelectContainer.querySelector('#historySelect');
      if (historySelect) {
        const domainSnapshots = getDomainSnapshots(appState.currentDomain);
        if (appState.currentSnapshotIndex === domainSnapshots.length - 1) {
          historySelect.value = 'latest';
        } else if (appState.currentSnapshotIndex > -1) {
          historySelect.value = String(appState.currentSnapshotIndex);
        }
      }
    }

    function displaySelectedSnapshot(domain, snapshotIndex) {
      const domainSnapshots = getDomainSnapshots(domain);

      if (snapshotIndex < 0 || snapshotIndex >= domainSnapshots.length) {
        showError('Selected historical snapshot not found.');
        return;
      }

      const selectedSnapshot = domainSnapshots[snapshotIndex];
      const recordsToDisplay = selectedSnapshot.records;
      let previousSnapshotRecords = snapshotIndex > 0 ? domainSnapshots[snapshotIndex - 1].records : null;

      let processedRecords;
      if (previousSnapshotRecords) {
        const comparisonResult = compareDnsRecords(recordsToDisplay, previousSnapshotRecords);
        processedRecords = [
          ...comparisonResult.added,
          ...comparisonResult.modified,
          ...comparisonResult.unchanged,
          ...comparisonResult.deleted
        ];
        processedRecords.sort((a, b) => {
          const typeOrder = RECORD_TYPES.indexOf(a.type) - RECORD_TYPES.indexOf(b.type);
          if (typeOrder !== 0) return typeOrder;
          const nameCompare = a.name.localeCompare(b.name);
          if (nameCompare !== 0) return nameCompare;
          const statusOrder = { added: 1, modified: 2, deleted: 3, unchanged: 4 };
          return statusOrder[a.status] - statusOrder[b.status];
        });
      } else {
        processedRecords = recordsToDisplay.map((r) => ({ ...r, status: 'unchanged' }));
      }

      DOMElements.initialMessage.classList.add('hidden');
      DOMElements.resultsHeader.classList.add('flex');
      DOMElements.resultsHeader.classList.remove('hidden');
      DOMElements.historySelectContainer.classList.remove('hidden');
      DOMElements.exportBtn.classList.remove('hidden');

      updateState({
        dnsRecords: processedRecords,
        currentDomain: domain,
        currentSnapshotIndex: snapshotIndex
      });
    }

    function exportRecordsToTxt() {
      if (!appState.dnsRecords || appState.dnsRecords.length === 0) {
        showUserFeedback('No DNS records to export!', 'warning');
        return;
      }

      let fileContent = `DNS Records for ${appState.currentDomain || 'unknown-domain'}\n`;
      fileContent += `Generated on: ${new Date().toLocaleString()}\n\n`;

      const recordsByType = {};
      RECORD_TYPES.forEach((type) => {
        recordsByType[type] = appState.dnsRecords.filter((r) => r.type === type);
      });

      RECORD_TYPES.forEach((type) => {
        const records = recordsByType[type];
        if (records.length > 0) {
          fileContent += `--- ${type} Records (${records.length}) ---\n`;
          const sortedTypeRecords = sortRecords(records, 'name', 'asc');
          sortedTypeRecords.forEach((record) => {
            const status = record.status ? ` (${record.status})` : '';
            const oldData = record.status === 'modified' && record.oldData !== undefined
              ? ` (was: ${normalizeTxtData(record.oldData)})`
              : '';
            fileContent += `Name: ${record.name}\n`;
            fileContent += `Type: ${record.type}\n`;
            fileContent += `Data: ${normalizeTxtData(record.data)}${oldData}\n`;
            fileContent += `TTL: ${record.ttl}${status}\n`;
            fileContent += `---------------------------------\n`;
          });
          fileContent += `\n`;
        }
      });

      const filename = `dns_records_${appState.currentDomain.replace(/[^a-zA-Z0-9-.]/g, '_') || 'export'}.txt`;
      const blob = new Blob([fileContent], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showUserFeedback('DNS records exported successfully.', 'success');
    }

    // Theme management
    function setTheme(theme) {
      updateState({ theme }, false); // Update state, but let state management handle DOM for theme
      saveToLocalStorage(LOCAL_STORAGE_THEME_KEY, theme);
    }

    function toggleTheme() {
      const newTheme = appState.theme === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
    }

    function initializeTheme() {
      const savedTheme = loadFromLocalStorage(LOCAL_STORAGE_THEME_KEY);
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');
      setTheme(initialTheme);
    }

    // Debounce utility
    function debounce(func, wait) {
      return function (...args) {
        clearTimeout(appState.debounceTimeout);
        appState.debounceTimeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    // --- Event Delegation & Handlers ---
    document.addEventListener('click', (e) => {
      // Copyable elements
      const copyableElement = e.target.closest('.copyable');
      if (copyableElement) {
        e.stopPropagation();
        const text = copyableElement.getAttribute('data-copy');
        const field = copyableElement.getAttribute('aria-label').replace(/Copy DNS (name|data|TTL)(?::.*)?/, '$1');
        copyToClipboard(text, copyableElement, field);
      }

      // Autocomplete list items
      const autocompleteItem = e.target.closest('#domainAutocompleteList div');
      if (autocompleteItem) {
        DOMElements.domainInput.value = autocompleteItem.textContent;
        performDNSLookup(autocompleteItem.textContent);
        hideAutocompleteList();
        DOMElements.domainInput.focus();
        return; // Stop further processing for this click
      }

      // Hide autocomplete if clicked outside
      if (e.target !== DOMElements.domainInput && !DOMElements.domainAutocompleteList.contains(e.target)) {
        hideAutocompleteList();
      }

      // Details/Summary Toggle for ARIA
      const summaryElement = e.target.closest('summary');
      if (summaryElement) {
        const detailsElement = summaryElement.parentNode;
        if (detailsElement.tagName === 'DETAILS') {
            const isExpanded = detailsElement.open;
            // The `open` attribute toggles first, then the event fires.
            // So, `detailsElement.open` will be the new state.
            summaryElement.setAttribute('aria-expanded', detailsElement.open ? 'true' : 'false');
        }
      }
    });

    document.addEventListener('keydown', (e) => {
      const items = DOMElements.domainAutocompleteList.getElementsByTagName('div');
      if (e.target === DOMElements.domainInput) {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          updateState({ currentAutocompleteFocus: appState.currentAutocompleteFocus + 1 }, false);
          addActive(items);
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          updateState({ currentAutocompleteFocus: appState.currentAutocompleteFocus - 1 }, false);
          addActive(items);
        } else if (e.key === 'Enter') {
          e.preventDefault();
          selectAutocompleteItem();
        } else if (e.key === 'Escape') {
          hideAutocompleteList();
        }
      }

      // Keyboard support for copyable and sortable elements
      const activeElement = document.activeElement;
      if (e.key === 'Enter' || e.key === ' ') {
        if (activeElement && activeElement.classList.contains('copyable')) {
          e.preventDefault();
          const text = activeElement.getAttribute('data-copy');
          const field = activeElement.getAttribute('aria-label').replace(/Copy DNS (name|data|TTL)(?::.*)?/, '$1');
          copyToClipboard(text, activeElement, field);
        } else if (activeElement && activeElement.tagName === 'TH' && activeElement.hasAttribute('data-sort')) {
          e.preventDefault();
          const column = activeElement.getAttribute('data-sort');
          const type = activeElement.getAttribute('data-type');
          let direction = 'asc';
          if (appState.currentSort[type] && appState.currentSort[type].column === column) {
            direction = appState.currentSort[type].direction === 'asc' ? 'desc' : 'asc';
          }
          appState.currentSort[type] = { column, direction }; // Update directly in state
          renderSections(appState.dnsRecords); // Re-render the relevant section
        } else if (activeElement && activeElement.tagName === 'SUMMARY') {
            // Let native details/summary handle space/enter for toggling
        } else if (activeElement && activeElement.id === 'lookupBtn') {
            e.preventDefault(); // Prevent default for space bar on button, enter already handled by form submission
            performDNSLookup(DOMElements.domainInput.value.trim());
        }
      }
    });

    DOMElements.domainInput.addEventListener('input', debounce(() => {
      const inputValue = DOMElements.domainInput.value.trim();
      renderAutocompleteList(inputValue);
    }, DEBOUNCE_DELAY));

    // Global delegation for other actions
    document.addEventListener('change', (e) => {
        if (e.target === DOMElements.filterType) {
            updateState({ filterType: e.target.value });
        } else if (e.target === DOMElements.themeToggle) {
            toggleTheme();
        } else if (e.target.dataset.action === 'select-history' && e.target.id === 'historySelect') {
            const selectedValue = e.target.value;
            let newSnapshotIndex;
            if (selectedValue === 'latest') {
              newSnapshotIndex = getDomainSnapshots(appState.currentDomain).length - 1;
            } else {
              newSnapshotIndex = parseInt(selectedValue, 10);
            }
            displaySelectedSnapshot(appState.currentDomain, newSnapshotIndex);
        }
    });

    DOMElements.lookupBtn.addEventListener('click', () => {
      performDNSLookup(DOMElements.domainInput.value.trim());
    });

    DOMElements.clearHistoryBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to clear all stored DNS history and records? This cannot be undone.')) {
        try {
          localStorage.clear();
          resetUI();
          showUserFeedback('All local storage data has been cleared.', 'success');
        } catch (e) {
          showUserFeedback('Failed to clear local storage.', 'error');
        }
      }
    });

    DOMElements.exportBtn.addEventListener('click', exportRecordsToTxt);


    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      initializeTheme();
      resetUI();
      const lastDomain = loadSearchHistory()[0];
      if (lastDomain) {
        DOMElements.domainInput.value = lastDomain;
      }
    });
  </script>
</body>
</html>
